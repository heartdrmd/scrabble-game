<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrabble</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            /* Blue board theme - DEFAULT */
            --board-bg: rgb(169, 198, 229);
            --board-lines: rgb(149, 178, 209);
            --triple-word: #e06070;
            --triple-word-text: #fff;
            --double-word: #f0a8b8;
            --double-word-text: #5a3038;
            --triple-letter: #40a0b0;
            --triple-letter-text: #fff;
            --double-letter: #90c8e0;
            --double-letter-text: #284858;
            --center-bg: #f0a8b8;
            --center-star: #c05068;
            --frame-dark: #5c4a3a;
            --frame-mid: #7a6352;
            --frame-light: #96806c;
            --frame-accent: #c9a227;
            --tile-border: #a07050;
            --tile-border-light: #c89878;
            --tile-face-1: #e8cdb8;
            --tile-face-2: #dfc0a8;
            --tile-face-3: #d4b090;
            --tile-face-4: #c8a078;
            --tile-text: #2a2018;
            --text-light: #f5f0e6;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(145deg, #2d2d2d 0%, #1a1a1a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            color: var(--text-light);
        }

        h1 {
            color: var(--frame-accent);
            font-size: 1.8rem;
            letter-spacing: 6px;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .mode-btn {
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px solid var(--frame-mid);
            background: transparent;
            color: var(--text-light);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn:hover, .mode-btn.active {
            background: var(--frame-accent);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
        }

        .board-section {
            position: relative;
        }

        .timer-display {
            position: absolute;
            top: -45px;
            right: 0;
            background: rgba(0,0,0,0.85);
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 20px;
            font-weight: bold;
            color: #4ade80;
            display: none;
            border: 2px solid rgba(255,255,255,0.1);
            z-index: 100;
        }

        .timer-display.warning {
            color: #fbbf24;
            border-color: rgba(251,191,36,0.3);
        }

        .timer-display.critical {
            color: #ef4444;
            border-color: rgba(239,68,68,0.3);
            animation: timer-pulse 0.5s ease infinite;
        }

        .timer-display.grace {
            color: #ef4444;
            background: rgba(239,68,68,0.2);
            border-color: #ef4444;
            animation: timer-pulse 0.3s ease infinite;
        }

        @keyframes timer-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .rack-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 200px;
            max-width: 220px;
        }

        .ai-response-box {
            background: rgba(60, 50, 80, 0.4);
            border: 1px solid rgba(140, 120, 180, 0.4);
            border-radius: 6px;
            display: none;
            max-height: 150px;
            overflow: hidden;
        }

        .ai-response-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: rgba(0,0,0,0.2);
            font-size: 10px;
            font-weight: 600;
        }

        .clear-btn {
            background: none;
            border: none;
            color: #aaa;
            font-size: 14px;
            cursor: pointer;
            padding: 0 4px;
        }

        .clear-btn:hover {
            color: #fff;
        }

        .ai-response-text {
            padding: 8px 10px;
            font-size: 11px;
            line-height: 1.4;
            max-height: 110px;
            overflow-y: auto;
            color: #e8e0f0;
        }

        .rack-buttons-row {
            display: flex;
            gap: 6px;
        }

        .rack-buttons-row .btn {
            flex: 1;
            padding: 8px 6px;
            font-size: 10px;
        }

        .define-btn {
            background: linear-gradient(145deg, #5a7a5a, #3a5a3a);
        }

        .define-btn:hover {
            background: linear-gradient(145deg, #7a9a7a, #4a6a4a);
        }

        .rack-frame-horizontal {
            background: linear-gradient(145deg, var(--frame-light), var(--frame-mid) 50%, var(--frame-dark));
            padding: 8px 10px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.1);
        }

        .rack-frame-horizontal .rack {
            display: flex;
            flex-direction: row;
            gap: 3px;
            min-height: 44px;
            justify-content: center;
        }

        .rack-frame-horizontal .rack .tile {
            width: 28px;
            height: 34px;
        }

        .rack-frame-horizontal .rack .tile .letter {
            font-size: 16px;
        }

        .rack-frame-horizontal .rack .tile .points {
            font-size: 7px;
        }

        .btn-group-vertical {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .btn-group-vertical .btn {
            width: 100%;
        }

        .debug-btn {
            margin-top: auto;
            background: rgba(100,100,100,0.3);
            border-color: #666;
            font-size: 10px;
        }

        .debug-btn:hover {
            background: rgba(100,100,100,0.5);
        }

        .board-frame {
            /* Wood grain texture on frame */
            background: 
                repeating-linear-gradient(
                    92deg,
                    transparent 0px,
                    transparent 2px,
                    rgba(0,0,0,0.03) 2px,
                    rgba(0,0,0,0.03) 3px
                ),
                repeating-linear-gradient(
                    88deg,
                    transparent 0px,
                    transparent 4px,
                    rgba(255,255,255,0.02) 4px,
                    rgba(255,255,255,0.02) 5px
                ),
                linear-gradient(145deg, #4a3a2a, #3a2a1a 50%, #2a1a0a);
            padding: 18px;
            border-radius: 8px;
            position: relative;
            
            /* 3D raised effect - thicker and more defined */
            box-shadow: 
                /* Outer glow/shadow */
                0 16px 40px rgba(0,0,0,0.6),
                0 10px 25px rgba(0,0,0,0.5),
                /* Thick bottom/right edge */
                5px 5px 0 #3a2a1a,
                8px 8px 0 #2a1a0a,
                10px 10px 0 #1a0a00,
                12px 12px 0 #100500,
                /* Far shadow */
                15px 25px 35px rgba(0,0,0,0.5);
            
            /* Dark border for definition */
            border: 3px solid #1a0a00;
        }

        /* Top bevel - light hitting the top edge */
        .board-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            background: linear-gradient(to bottom, 
                rgba(255,255,255,0.25) 0%, 
                rgba(255,255,255,0.1) 40%,
                transparent 100%);
            border-radius: 8px 8px 0 0;
            pointer-events: none;
        }

        /* Left bevel - light hitting the left edge */
        .board-frame::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 12px;
            width: 6px;
            background: linear-gradient(to right, 
                rgba(255,255,255,0.2) 0%, 
                rgba(255,255,255,0.08) 40%,
                transparent 100%);
            border-radius: 8px 0 0 8px;
            pointer-events: none;
        }

        .board-inner {
            background: var(--board-lines);
            padding: 3px;
            border-radius: 4px;
            position: relative;
            /* Recessed playing surface */
            box-shadow: 
                inset 0 4px 12px rgba(0,0,0,0.5),
                inset 0 2px 6px rgba(0,0,0,0.4),
                inset 4px 0 10px rgba(0,0,0,0.25),
                /* Outer lip catch light */
                0 1px 0 rgba(255,255,255,0.12),
                1px 0 0 rgba(255,255,255,0.06);
            border: 2px solid rgba(0,0,0,0.3);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(15, 32px);
            gap: 2px;
        }

        .cell {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4px;
            font-weight: 700;
            text-transform: uppercase;
            line-height: 1.1;
            text-align: center;
            border-radius: 1px;
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .cell.normal { background: var(--board-bg); }
        .cell.DL { background: var(--double-letter); color: var(--double-letter-text); }
        .cell.TL { background: var(--triple-letter); color: var(--triple-letter-text); }
        .cell.DW { background: var(--double-word); color: var(--double-word-text); }
        .cell.TW { background: var(--triple-word); color: var(--triple-word-text); }
        .cell.center { background: var(--center-bg); }
        .cell.center .star { font-size: 14px; color: var(--center-star); }

        .cell.selected {
            box-shadow: inset 0 0 0 2px var(--frame-accent), 0 0 10px rgba(201,162,39,0.5);
        }

        .cell.typing-start {
            box-shadow: inset 0 0 0 3px #4ade80;
        }

        .cell .premium-text {
            font-size: 4px;
            font-weight: 700;
            line-height: 1.1;
            pointer-events: none;
        }

        .tile {
            width: 28px;
            height: 28px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: grab;
            user-select: none;
            background: linear-gradient(160deg, var(--tile-border-light), var(--tile-border));
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            z-index: 10;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .tile::before {
            content: '';
            position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            border-radius: 2px;
            background: 
                repeating-linear-gradient(95deg, transparent 0px, transparent 3px, rgba(160,120,80,0.08) 3px, rgba(160,120,80,0.08) 4px),
                linear-gradient(165deg, var(--tile-face-1), var(--tile-face-2) 30%, var(--tile-face-3) 70%, var(--tile-face-4));
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.7), inset 0 -1px 2px rgba(0,0,0,0.1);
        }

        .tile .letter {
            position: relative;
            z-index: 2;
            font-size: 16px;
            font-weight: 700;
            color: var(--tile-text);
        }

        .tile .points {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 6px;
            font-weight: 600;
            color: var(--tile-text);
            z-index: 2;
        }

        .tile.selected {
            transform: scale(1.1);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 3px var(--frame-accent);
        }

        .tile.placed-this-turn {
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 2px var(--frame-accent);
            cursor: pointer;
        }

        .tile.dragging { opacity: 0.7; cursor: grabbing; }

        /* Hint preview tiles */
        .tile.hint-preview {
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 2px #4ade80, 0 0 12px rgba(74,222,128,0.4);
            animation: hint-pulse 1.5s ease infinite;
        }

        @keyframes hint-pulse {
            0%, 100% { box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 2px #4ade80, 0 0 12px rgba(74,222,128,0.4); }
            50% { box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 3px #4ade80, 0 0 20px rgba(74,222,128,0.6); }
        }

        /* Floating tile that follows cursor */
        .tile.floating {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%) scale(1.15);
            box-shadow: 4px 6px 12px rgba(0,0,0,0.5), 0 0 0 3px var(--frame-accent);
        }

        /* Direction arrow indicator */
        .direction-arrow {
            position: absolute;
            font-size: 18px;
            color: #4ade80;
            z-index: 5;
            text-shadow: 0 0 4px rgba(74,222,128,0.8);
            animation: pulse 1s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .cell.can-drop {
            background: rgba(74,222,128,0.3) !important;
        }

        .rack-area { display: flex; flex-direction: column; gap: 10px; }

        .rack-row {
            display: flex;
            align-items: stretch;
            gap: 10px;
        }

        .rack-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .hint-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 12px;
            font-size: 11px;
            gap: 4px;
            white-space: nowrap;
        }

        .clue-btn {
            background: linear-gradient(145deg, #6a5a8a, #4a3a6a);
        }

        .clue-btn:hover {
            background: linear-gradient(145deg, #8a7aaa, #5a4a7a);
        }

        .rack-frame {
            background: linear-gradient(145deg, var(--frame-light), var(--frame-dark));
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .rack-label {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 5px;
            text-align: center;
        }

        .rack {
            background: var(--frame-mid);
            padding: 6px 8px;
            border-radius: 4px;
            display: flex;
            gap: 4px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.4);
            min-width: 240px;
            min-height: 42px;
            justify-content: center;
            align-items: center;
        }

        .btn-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(145deg, var(--frame-light), var(--frame-dark));
            color: var(--text-light);
            border: 1px solid var(--frame-mid);
            padding: 8px 14px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn.primary {
            background: linear-gradient(145deg, var(--frame-accent), #a68520);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 160px;
        }

        .info-box {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .info-box h3 {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 2px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 13px;
        }

        .score-row.current { color: var(--frame-accent); }
        .score-row .score { font-weight: 700; }

        .word-preview {
            min-height: 24px;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
        }

        .word-chip {
            background: rgba(255,255,255,0.1);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
        }

        .word-chip.valid { background: rgba(46,160,67,0.3); color: #4ade80; }
        .word-chip.invalid { background: rgba(220,38,38,0.3); color: #f87171; }

        .message {
            text-align: center;
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .message.error { background: rgba(220,38,38,0.2); color: #f87171; }
        .message.success { background: rgba(46,160,67,0.2); color: #4ade80; }
        .message.info { background: rgba(59,130,246,0.2); color: #60a5fa; }

        .typing-input { position: fixed; top: -100px; opacity: 0; }

        .keyboard-hint {
            font-size: 10px;
            opacity: 0.6;
            text-align: center;
            padding: 5px;
        }

        .ai-thinking {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            padding: 10px;
            color: var(--frame-accent);
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--frame-mid);
            border-top-color: var(--frame-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .difficulty-select {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: var(--frame-dark);
            color: var(--text-light);
            font-size: 11px;
        }

        /* Theme Controls */
        .settings-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.05);
            overflow: hidden;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: background 0.2s;
        }

        .settings-header:hover {
            background: rgba(255,255,255,0.05);
        }

        .settings-arrow {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .settings-arrow.open {
            transform: rotate(180deg);
        }

        .settings-content {
            padding: 0 12px 12px;
        }

        .settings-section {
            margin-bottom: 12px;
        }

        .settings-section h4 {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .theme-presets {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
        }

        .theme-preset-btn {
            flex: 1;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: transparent;
            color: var(--text-light);
            font-size: 9px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .theme-preset-btn:hover, .theme-preset-btn.active {
            background: var(--frame-accent);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .theme-panel h3 {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 2px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .theme-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .theme-row label {
            font-size: 10px;
            min-width: 45px;
            opacity: 0.8;
        }

        .color-presets {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .color-preset {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-preset:hover {
            transform: scale(1.1);
        }

        .color-preset.active {
            border-color: var(--frame-accent);
            box-shadow: 0 0 8px rgba(201,162,39,0.5);
        }

        .theme-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #1a1a1a, #888, #fff);
            outline: none;
        }

        .theme-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--frame-accent);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .theme-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--frame-accent);
            cursor: pointer;
            border: none;
        }

        .color-picker-wrap {
            position: relative;
        }

        .color-picker-btn {
            width: 26px;
            height: 26px;
            border-radius: 4px;
            border: 2px solid var(--frame-mid);
            cursor: pointer;
            overflow: hidden;
        }

        .color-picker-btn input {
            position: absolute;
            width: 40px;
            height: 40px;
            top: -6px;
            left: -6px;
            cursor: pointer;
            opacity: 0;
        }

        .premium-colors {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .premium-color-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .premium-label {
            font-size: 8px;
            font-weight: 700;
            padding: 2px 4px;
            border-radius: 2px;
            min-width: 22px;
            text-align: center;
        }

        .premium-label.tw { background: #e06070; color: #fff; }
        .premium-label.dw { background: #f0a8b8; color: #5a3038; }
        .premium-label.tl { background: #40a0b0; color: #fff; }
        .premium-label.dl { background: #90c8e0; color: #284858; }

        .premium-picker {
            width: 28px;
            height: 20px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
        }

        .save-theme-row {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }

        .theme-name-input {
            flex: 1;
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: rgba(0,0,0,0.3);
            color: var(--text-light);
            font-size: 10px;
        }

        .btn-small {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: var(--frame-dark);
            color: var(--text-light);
            font-size: 9px;
            cursor: pointer;
        }

        .btn-small:hover {
            background: var(--frame-accent);
            color: #1a1a1a;
        }

        .saved-themes-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 80px;
            overflow-y: auto;
        }

        .saved-theme-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }

        .saved-theme-name {
            font-size: 10px;
            cursor: pointer;
        }

        .saved-theme-name:hover {
            color: var(--frame-accent);
        }

        .saved-theme-delete {
            font-size: 14px;
            cursor: pointer;
            opacity: 0.5;
        }

        .saved-theme-delete:hover {
            opacity: 1;
            color: #e85a70;
        }

        .tile-style-btn {
            flex: 1;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: transparent;
            color: var(--text-light);
            font-size: 9px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tile-style-btn:hover, .tile-style-btn.active {
            background: var(--frame-accent);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .timer-input {
            width: 60px;
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: rgba(0,0,0,0.3);
            color: var(--text-light);
            font-size: 11px;
            text-align: center;
        }

        /* Word tools */
        .word-tools {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }

        .word-tool-btn {
            flex: 1;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: rgba(0,0,0,0.3);
            color: var(--text-light);
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .word-tool-btn:hover {
            background: var(--frame-accent);
            color: #1a1a1a;
        }

        .word-tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .definition-box {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            font-size: 10px;
            line-height: 1.4;
            display: none;
        }

        .definition-box.visible {
            display: block;
        }

        .definition-word {
            color: var(--frame-accent);
            font-weight: 600;
            margin-bottom: 4px;
        }

        @media (max-width: 700px) {
            .game-container { flex-direction: column; }
            .board { grid-template-columns: repeat(15, 22px); }
            .cell { width: 22px; height: 22px; font-size: 3px; }
            .tile { width: 20px; height: 20px; }
            .tile .letter { font-size: 11px; }
            .tile .points { font-size: 5px; }
            .side-panel { width: 100%; flex-direction: row; flex-wrap: wrap; justify-content: center; }
        }
    </style>
</head>
<body>
    <h1>SCRABBLE</h1>

    <div class="mode-selector">
        <button class="mode-btn active" data-mode="2player">2 Player</button>
        <button class="mode-btn" data-mode="ai">vs AI</button>
        <select class="difficulty-select" id="difficulty" style="display:none;">
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard" selected>Hard</option>
        </select>
    </div>

    <div class="game-container">
        <div class="side-panel">
            <div class="info-box">
                <h3>Score</h3>
                <div class="score-row current" id="player1-score">
                    <span id="player1-name">You</span>
                    <span class="score">0</span>
                </div>
                <div class="score-row" id="player2-score">
                    <span id="player2-name">Player 2</span>
                    <span class="score">0</span>
                </div>
            </div>

            <div class="info-box">
                <h3>Turn</h3>
                <div id="turn-indicator" style="font-size:12px;">Your turn</div>
            </div>

            <div class="info-box">
                <h3>Words</h3>
                <div class="word-preview" id="word-preview">
                    <span style="opacity:0.5;font-size:10px;">Place tiles</span>
                </div>
            </div>

            <div class="info-box">
                <h3>Move</h3>
                <div class="score-row">
                    <span>Points</span>
                    <span class="score" id="move-score">0</span>
                </div>
            </div>

            <div style="text-align:center;opacity:0.6;font-size:11px;">
                Bag: <strong id="bag-count">86</strong>
            </div>

            <div class="settings-panel">
                <div class="settings-header" id="settings-toggle">
                    <span>‚öôÔ∏è Settings</span>
                    <span class="settings-arrow" id="settings-arrow">‚ñº</span>
                </div>
                <div class="settings-content" id="settings-content" style="display:none;">
                    <div class="settings-section">
                        <h4>Theme Presets</h4>
                        <div class="theme-presets">
                            <button class="theme-preset-btn active" data-theme="default">Ocean</button>
                            <button class="theme-preset-btn" data-theme="sage">Sage</button>
                            <button class="theme-preset-btn" data-theme="dark">Dark</button>
                            <button class="theme-preset-btn" data-theme="forest">Forest</button>
                            <button class="theme-preset-btn" data-theme="warm">Warm</button>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h4>Tile Style</h4>
                        <div class="theme-presets">
                            <button class="tile-style-btn active" data-style="wood">Wood</button>
                            <button class="tile-style-btn" data-style="ivory">Ivory</button>
                            <button class="tile-style-btn" data-style="dark">Dark</button>
                            <button class="tile-style-btn" data-style="blue">Blue</button>
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <h4>Board Color</h4>
                        <div class="color-presets" id="color-presets">
                            <div class="color-preset active" data-color="169,198,229" style="background:rgb(169,198,229);" title="Ocean"></div>
                            <div class="color-preset" data-color="142,142,80" style="background:#8e8e50;" title="Sage"></div>
                            <div class="color-preset" data-color="80,120,80" style="background:#507850;" title="Forest"></div>
                            <div class="color-preset" data-color="180,140,100" style="background:#b48c64;" title="Warm"></div>
                            <div class="color-preset" data-color="50,50,50" style="background:#323232;" title="Dark"></div>
                        </div>
                        <div class="theme-row">
                            <label>Custom</label>
                            <div class="color-picker-wrap">
                                <div class="color-picker-btn" id="color-picker-btn" style="background:rgb(169,198,229);">
                                    <input type="color" id="board-color-picker" value="#a9c6e5">
                                </div>
                            </div>
                        </div>
                        <div class="theme-row">
                            <label>Light</label>
                            <input type="range" class="theme-slider" id="lightness-slider" min="0" max="100" value="75">
                            <label style="min-width:auto;">Dark</label>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h4>Premium Squares</h4>
                        <div class="premium-colors">
                            <div class="premium-color-row">
                                <span class="premium-label tw">TW</span>
                                <input type="color" class="premium-picker" id="tw-color" value="#e06070">
                            </div>
                            <div class="premium-color-row">
                                <span class="premium-label dw">DW</span>
                                <input type="color" class="premium-picker" id="dw-color" value="#f0a8b8">
                            </div>
                            <div class="premium-color-row">
                                <span class="premium-label tl">TL</span>
                                <input type="color" class="premium-picker" id="tl-color" value="#40a0b0">
                            </div>
                            <div class="premium-color-row">
                                <span class="premium-label dl">DL</span>
                                <input type="color" class="premium-picker" id="dl-color" value="#90c8e0">
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h4>Timer (seconds, 0=off)</h4>
                        <div class="theme-row">
                            <input type="number" id="timer-setting" class="timer-input" value="0" min="0" max="300" step="10">
                            <button class="btn-small" onclick="applyTimerSetting()">Set</button>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h4>Save Theme</h4>
                        <div class="save-theme-row">
                            <input type="text" id="theme-name-input" placeholder="Theme name..." class="theme-name-input">
                            <button class="btn-small" onclick="saveCustomTheme(document.getElementById('theme-name-input').value)">Save</button>
                        </div>
                        <div class="saved-themes-list" id="saved-themes-list">
                            <span style="opacity:0.5;font-size:9px;">No saved themes</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="board-section">
            <div class="timer-display" id="timer-display"></div>
            <div class="board-frame">
                <div class="board-inner">
                    <div class="board" id="board"></div>
                </div>
            </div>
        </div>

        <div class="rack-panel">
            <div class="ai-response-box" id="ai-response-box">
                <div class="ai-response-header">
                    <span>üìù AI Response</span>
                    <button class="clear-btn" onclick="document.getElementById('ai-response-text').textContent=''; document.getElementById('ai-response-box').style.display='none';">√ó</button>
                </div>
                <div class="ai-response-text" id="ai-response-text"></div>
            </div>
            
            <div class="rack-buttons-row">
                <button class="btn hint-btn" id="btn-hint" title="Show best move">üí° Hint</button>
                <button class="btn hint-btn clue-btn" id="btn-funny-hint" title="Get witty clue">üé≠ Clue</button>
                <button class="btn hint-btn define-btn" id="btn-define" title="Define a word">üìñ Define</button>
            </div>

            <div class="btn-group-vertical">
                <button class="btn primary" id="btn-play" disabled>Play</button>
                <button class="btn" id="btn-recall">Recall</button>
                <button class="btn" id="btn-shuffle">Shuffle</button>
                <button class="btn" id="btn-pass">Pass</button>
            </div>

            <div class="rack-frame-horizontal">
                <div class="rack-label" id="rack-label">Your Rack</div>
                <div class="rack" id="rack"></div>
            </div>

            <div id="message" class="message" style="display:none;"></div>
            <div id="ai-thinking" class="ai-thinking" style="display:none;">
                <div class="spinner"></div>
                <span>AI thinking...</span>
            </div>

            <button class="btn debug-btn" id="btn-debug" title="Export debug log">üêõ Debug Log</button>
        </div>
    </div>

    <input type="text" class="typing-input" id="typing-input" autocomplete="off">
    <div class="tile floating" id="floating-tile" style="display:none;">
        <span class="letter"></span>
        <span class="points"></span>
    </div>

    <script>
        const BOARD_SIZE = 15;
        const LETTER_VALUES = {A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10,'?':0};
        const TILE_COUNTS = {A:9,B:2,C:2,D:4,E:12,F:2,G:3,H:2,I:9,J:1,K:1,L:4,M:2,N:6,O:8,P:2,Q:1,R:6,S:4,T:6,U:4,V:2,W:2,X:1,Y:2,Z:1,'?':2};
        const TW = [[0,0],[0,7],[0,14],[7,0],[7,14],[14,0],[14,7],[14,14]];
        const DW = [[1,1],[2,2],[3,3],[4,4],[1,13],[2,12],[3,11],[4,10],[13,1],[12,2],[11,3],[10,4],[13,13],[12,12],[11,11],[10,10],[7,7]];
        const TL = [[1,5],[1,9],[5,1],[5,5],[5,9],[5,13],[9,1],[9,5],[9,9],[9,13],[13,5],[13,9]];
        const DL = [[0,3],[0,11],[2,6],[2,8],[3,0],[3,7],[3,14],[6,2],[6,6],[6,8],[6,12],[7,3],[7,11],[8,2],[8,6],[8,8],[8,12],[11,0],[11,7],[11,14],[12,6],[12,8],[14,3],[14,11]];

        let board = Array(15).fill(null).map(() => Array(15).fill(null));
        let bag = [], currentPlayer = 1, scores = [0, 0];
        let racks = [[], []], placedThisTurn = [], isFirstMove = true;
        let selectedTile = null, selectedLetter = null, typingCell = null, typingDirection = null;
        let gameMode = '2player', aiDifficulty = 'hard', draggedTile = null;
        let floatingTile = null;
        let recentlyPlayedWords = [];

        // Debug logging system
        let debugLog = [];
        const MAX_LOG_ENTRIES = 500;

        function log(category, message, data = null) {
            const timestamp = new Date().toISOString();
            const entry = { timestamp, category, message, data };
            debugLog.push(entry);
            if (debugLog.length > MAX_LOG_ENTRIES) debugLog.shift();
            console.log(`[${category}] ${message}`, data || '');
        }

        function exportDebugLog() {
            const gameState = {
                board: board.map((row, r) => row.map((cell, c) => cell ? { letter: cell.letter, isBlank: cell.isBlank } : null)),
                scores: scores,
                currentPlayer: currentPlayer,
                racks: racks,
                bagCount: bag.length,
                gameMode: gameMode,
                aiDifficulty: aiDifficulty,
                timerSettings: { timerSeconds, currentTimer, graceMode }
            };

            let content = '=== SCRABBLE DEBUG LOG ===\n';
            content += `Exported: ${new Date().toISOString()}\n`;
            content += `User Agent: ${navigator.userAgent}\n\n`;
            
            content += '=== GAME STATE ===\n';
            content += JSON.stringify(gameState, null, 2) + '\n\n';
            
            content += '=== EVENT LOG ===\n';
            debugLog.forEach(entry => {
                content += `[${entry.timestamp}] [${entry.category}] ${entry.message}`;
                if (entry.data) content += ' | ' + JSON.stringify(entry.data);
                content += '\n';
            });

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `scrabble-debug-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showMessage('Debug log exported!', 'success');
        }

        // Add debug button handler
        document.addEventListener('DOMContentLoaded', () => {
            const debugBtn = document.getElementById('btn-debug');
            if (debugBtn) debugBtn.addEventListener('click', exportDebugLog);
        });

        function initBag() {
            bag = [];
            for (let letter in TILE_COUNTS) {
                for (let i = 0; i < TILE_COUNTS[letter]; i++) bag.push(letter);
            }
            shuffleArray(bag);
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function drawTiles(n) { return bag.splice(0, Math.min(n, bag.length)); }
        function getCurrentRack() { return racks[currentPlayer - 1]; }
        function setCurrentRack(r) { racks[currentPlayer - 1] = r; }

        function getCellType(r, c) {
            if (r === 7 && c === 7) return 'center';
            if (TW.some(p => p[0] === r && p[1] === c)) return 'TW';
            if (DW.some(p => p[0] === r && p[1] === c)) return 'DW';
            if (TL.some(p => p[0] === r && p[1] === c)) return 'TL';
            if (DL.some(p => p[0] === r && p[1] === c)) return 'DL';
            return 'normal';
        }

        function createTileElement(letter, inRack = false) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.dataset.letter = letter;
            tile.draggable = inRack;
            tile.innerHTML = `<span class="letter">${letter === '?' ? '' : letter}</span><span class="points">${LETTER_VALUES[letter]}</span>`;
            if (inRack) {
                let isDragging = false;
                
                tile.addEventListener('mousedown', () => { isDragging = false; });
                tile.addEventListener('dragstart', (e) => {
                    isDragging = true;
                    handleDragStart(e);
                });
                tile.addEventListener('dragend', handleDragEnd);
                tile.addEventListener('click', (e) => {
                    // Only handle click if not dragging
                    if (!isDragging) {
                        handleTileClick(tile);
                    }
                    isDragging = false;
                });
            }
            return tile;
        }

        function initBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    const type = getCellType(r, c);
                    cell.className = 'cell ' + type;
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    if (type === 'TW') cell.innerHTML = '<span class="premium-text">TRIPLE<br>WORD</span>';
                    else if (type === 'DW' && !(r === 7 && c === 7)) cell.innerHTML = '<span class="premium-text">DOUBLE<br>WORD</span>';
                    else if (type === 'TL') cell.innerHTML = '<span class="premium-text">TRIPLE<br>LETTER</span>';
                    else if (type === 'DL') cell.innerHTML = '<span class="premium-text">DOUBLE<br>LETTER</span>';
                    else if (type === 'center') cell.innerHTML = '<span class="star">‚òÖ</span>';
                    cell.addEventListener('click', () => handleCellClick(r, c, cell));
                    cell.addEventListener('dragover', e => { 
                        e.preventDefault(); 
                        const r = parseInt(cell.dataset.row);
                        const c = parseInt(cell.dataset.col);
                        // Allow drop on empty cells or cells with placed-this-turn tiles
                        if (!board[r][c] || placedThisTurn.some(p => p.row === r && p.col === c)) {
                            cell.classList.add('selected'); 
                        }
                    });
                    cell.addEventListener('dragleave', () => cell.classList.remove('selected'));
                    cell.addEventListener('drop', e => { 
                        e.preventDefault(); 
                        cell.classList.remove('selected'); 
                        const r = parseInt(cell.dataset.row);
                        const c = parseInt(cell.dataset.col);
                        
                        if (draggedPlacedTile) {
                            // Relocating a placed tile
                            relocatePlacedTile(r, c);
                        } else if (draggedTile) {
                            // Placing from rack
                            if (!board[r][c] || placedThisTurn.some(p => p.row === r && p.col === c)) {
                                placeTile(draggedTile.dataset.letter, r, c, cell);
                            }
                        }
                    });
                    boardEl.appendChild(cell);
                }
            }
        }

        function renderRack() {
            const rackEl = document.getElementById('rack');
            rackEl.innerHTML = '';
            getCurrentRack().forEach(l => rackEl.appendChild(createTileElement(l, true)));
            
            // Click on rack area to deselect
            rackEl.onclick = (e) => {
                if (e.target === rackEl && selectedTile) {
                    deselectTile();
                }
            };
        }

        function deselectTile() {
            if (selectedTile) selectedTile.classList.remove('selected');
            selectedTile = null;
            selectedLetter = null;
            hideFloatingTile();
            clearTypingMode();
        }

        function showFloatingTile(letter) {
            floatingTile = document.getElementById('floating-tile');
            floatingTile.querySelector('.letter').textContent = letter === '?' ? '?' : letter;
            floatingTile.querySelector('.points').textContent = LETTER_VALUES[letter];
            floatingTile.style.display = 'flex';
        }

        function hideFloatingTile() {
            const ft = document.getElementById('floating-tile');
            ft.style.display = 'none';
            floatingTile = null;
        }

        function handleTileClick(tile) {
            clearTypingMode();
            
            if (selectedTile === tile) {
                // Clicking same tile deselects
                deselectTile();
            } else {
                // Select new tile
                if (selectedTile) selectedTile.classList.remove('selected');
                selectedTile = tile;
                selectedLetter = tile.dataset.letter;
                tile.classList.add('selected');
                showFloatingTile(selectedLetter);
            }
        }

        // Click on placed tile to return to rack
        function handlePlacedTileClick(row, col, e) {
            e.stopPropagation();
            const placement = placedThisTurn.find(p => p.row === row && p.col === col);
            if (placement) {
                // Return to rack
                board[row][col] = null;
                getCurrentRack().push(placement.originalLetter);
                placedThisTurn = placedThisTurn.filter(p => p !== placement);
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                restoreCell(cell, row, col);
                renderRack();
                updateWordPreview();
            }
        }

        // Track mouse for floating tile
        document.addEventListener('mousemove', (e) => {
            if (floatingTile) {
                floatingTile.style.left = e.clientX + 'px';
                floatingTile.style.top = e.clientY + 'px';
            }
        });

        function handleCellClick(row, col, cell) {
            // If cell has a tile placed this turn, return it
            const placement = placedThisTurn.find(p => p.row === row && p.col === col);
            if (placement) {
                handlePlacedTileClick(row, col, event);
                return;
            }
            
            // If cell has permanent tile, ignore
            if (board[row][col]) return;
            
            if (selectedTile) {
                // Place selected tile
                placeTile(selectedTile.dataset.letter, row, col, cell);
                selectedTile.classList.remove('selected');
                selectedTile = null;
                selectedLetter = null;
                hideFloatingTile();
            } else if (!typingCell) {
                // Start typing mode
                startTypingMode(row, col, cell);
            } else if (typingCell.row === row && typingCell.col === col) {
                // Clicking same cell toggles direction
                toggleTypingDirection(cell);
            } else {
                // Clicking different cell, restart typing there
                clearTypingMode();
                startTypingMode(row, col, cell);
            }
        }

        function placeTile(letter, row, col, cell, isBlank = false) {
            let actual = letter;
            let originalLetter = letter;
            
            if (letter === '?') {
                actual = prompt('Blank letter (A-Z):')?.toUpperCase();
                if (!actual || !/^[A-Z]$/.test(actual)) return false;
                originalLetter = '?';
                isBlank = true;
            }
            
            const rack = getCurrentRack(), idx = rack.indexOf(isBlank ? '?' : letter);
            if (idx === -1 && !isBlank) return false;
            if (idx !== -1) rack.splice(idx, 1);

            const prev = placedThisTurn.find(p => p.row === row && p.col === col);
            if (prev) { rack.push(prev.originalLetter); placedThisTurn = placedThisTurn.filter(p => p !== prev); }

            const tile = createTileElement(actual);
            tile.classList.add('placed-this-turn');
            tile.draggable = true;
            tile.dataset.placedRow = row;
            tile.dataset.placedCol = col;
            tile.dataset.originalLetter = isBlank ? '?' : actual;
            if (isBlank) tile.dataset.isBlank = 'true';
            
            // Click placed tile to return to rack
            tile.onclick = (e) => handlePlacedTileClick(row, col, e);
            
            // Drag placed tile to relocate
            tile.addEventListener('dragstart', handlePlacedDragStart);
            tile.addEventListener('dragend', handlePlacedDragEnd);
            
            cell.innerHTML = '';
            cell.appendChild(tile);

            board[row][col] = { letter: actual, isBlank: isBlank };
            placedThisTurn.push({ row, col, letter: actual, originalLetter: isBlank ? '?' : actual, element: tile });

            renderRack();
            updateWordPreview();
            return true;
        }
        
        let draggedPlacedTile = null;
        let draggedFromRow = null;
        let draggedFromCol = null;
        
        function handlePlacedDragStart(e) {
            e.stopPropagation();
            draggedPlacedTile = e.target.closest('.tile');
            draggedFromRow = parseInt(draggedPlacedTile.dataset.placedRow);
            draggedFromCol = parseInt(draggedPlacedTile.dataset.placedCol);
            draggedPlacedTile.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handlePlacedDragEnd(e) {
            if (draggedPlacedTile) {
                draggedPlacedTile.classList.remove('dragging');
            }
            draggedPlacedTile = null;
            draggedFromRow = null;
            draggedFromCol = null;
            document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
        }
        
        function relocatePlacedTile(toRow, toCol) {
            if (draggedFromRow === null || draggedFromCol === null) return;
            if (toRow === draggedFromRow && toCol === draggedFromCol) return;
            
            // Get the placement info
            const placement = placedThisTurn.find(p => p.row === draggedFromRow && p.col === draggedFromCol);
            if (!placement) return;
            
            // Check if target is empty or has a placed-this-turn tile
            if (board[toRow][toCol] && !placedThisTurn.some(p => p.row === toRow && p.col === toCol)) {
                return; // Can't drop on permanent tile
            }
            
            // Remove from old position
            board[draggedFromRow][draggedFromCol] = null;
            const oldCell = document.querySelector(`.cell[data-row="${draggedFromRow}"][data-col="${draggedFromCol}"]`);
            restoreCell(oldCell, draggedFromRow, draggedFromCol);
            
            // If target has a placed tile, swap them
            const targetPlacement = placedThisTurn.find(p => p.row === toRow && p.col === toCol);
            if (targetPlacement) {
                // Move target tile to old position
                board[draggedFromRow][draggedFromCol] = { letter: targetPlacement.letter, isBlank: targetPlacement.originalLetter === '?' };
                targetPlacement.row = draggedFromRow;
                targetPlacement.col = draggedFromCol;
                
                const swapTile = createTileElement(targetPlacement.letter);
                swapTile.classList.add('placed-this-turn');
                swapTile.draggable = true;
                swapTile.dataset.placedRow = draggedFromRow;
                swapTile.dataset.placedCol = draggedFromCol;
                swapTile.dataset.originalLetter = targetPlacement.originalLetter;
                if (targetPlacement.originalLetter === '?') swapTile.dataset.isBlank = 'true';
                swapTile.onclick = (ev) => handlePlacedTileClick(draggedFromRow, draggedFromCol, ev);
                swapTile.addEventListener('dragstart', handlePlacedDragStart);
                swapTile.addEventListener('dragend', handlePlacedDragEnd);
                oldCell.innerHTML = '';
                oldCell.appendChild(swapTile);
                targetPlacement.element = swapTile;
            }
            
            // Place at new position
            const newCell = document.querySelector(`.cell[data-row="${toRow}"][data-col="${toCol}"]`);
            const newTile = createTileElement(placement.letter);
            newTile.classList.add('placed-this-turn');
            newTile.draggable = true;
            newTile.dataset.placedRow = toRow;
            newTile.dataset.placedCol = toCol;
            newTile.dataset.originalLetter = placement.originalLetter;
            if (placement.originalLetter === '?') newTile.dataset.isBlank = 'true';
            newTile.onclick = (ev) => handlePlacedTileClick(toRow, toCol, ev);
            newTile.addEventListener('dragstart', handlePlacedDragStart);
            newTile.addEventListener('dragend', handlePlacedDragEnd);
            
            newCell.innerHTML = '';
            newCell.appendChild(newTile);
            
            board[toRow][toCol] = { letter: placement.letter, isBlank: placement.originalLetter === '?' };
            placement.row = toRow;
            placement.col = toCol;
            placement.element = newTile;
            
            updateWordPreview();
        }

        function startTypingMode(row, col, cell) {
            typingCell = { row, col, element: cell };
            typingDirection = 'H'; // Default horizontal
            cell.classList.add('typing-start');
            showDirectionArrow(cell, 'H');
            document.getElementById('keyboard-hint').textContent = 'Type letters, ‚Üë/‚Üì/‚Üê/‚Üí change direction, ESC cancel';
            document.getElementById('typing-input').value = '';
            document.getElementById('typing-input').focus();
        }

        function toggleTypingDirection(cell) {
            typingDirection = typingDirection === 'H' ? 'V' : 'H';
            showDirectionArrow(cell, typingDirection);
        }

        function showDirectionArrow(cell, direction) {
            // Remove existing arrows
            document.querySelectorAll('.direction-arrow').forEach(a => a.remove());
            
            const arrow = document.createElement('span');
            arrow.className = 'direction-arrow';
            arrow.textContent = direction === 'H' ? '‚Üí' : '‚Üì';
            cell.appendChild(arrow);
        }

        function clearTypingMode() {
            if (typingCell) typingCell.element.classList.remove('typing-start');
            document.querySelectorAll('.direction-arrow').forEach(a => a.remove());
            typingCell = typingDirection = null;
            document.getElementById('keyboard-hint').textContent = 'Click tile ‚Üí click cell, OR click cell ‚Üí type word';
        }

        document.getElementById('typing-input').addEventListener('keydown', e => {
            if (!typingCell) return;
            if (e.key === 'Escape') { clearTypingMode(); return; }
            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                typingDirection = 'H';
                showDirectionArrow(typingCell.element, 'H');
                e.preventDefault();
                return;
            }
            if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                typingDirection = 'V';
                showDirectionArrow(typingCell.element, 'V');
                e.preventDefault();
                return;
            }
            if (e.key === 'Enter') { clearTypingMode(); return; }
            if (e.key === 'Backspace' && placedThisTurn.length > 0) {
                const last = placedThisTurn.pop();
                board[last.row][last.col] = null;
                getCurrentRack().push(last.originalLetter);
                restoreCell(document.querySelector(`.cell[data-row="${last.row}"][data-col="${last.col}"]`), last.row, last.col);
                renderRack();
                updateWordPreview();
                e.preventDefault();
                return;
            }
            if (/^[A-Za-z]$/.test(e.key)) {
                let row = typingCell.row, col = typingCell.col;
                if (placedThisTurn.length > 0) {
                    const last = placedThisTurn[placedThisTurn.length - 1];
                    row = last.row + (typingDirection === 'V' ? 1 : 0);
                    col = last.col + (typingDirection === 'H' ? 1 : 0);
                }
                // Skip existing tiles
                while (row < 15 && col < 15 && board[row][col] && !placedThisTurn.some(p => p.row === row && p.col === col)) {
                    row += typingDirection === 'V' ? 1 : 0;
                    col += typingDirection === 'H' ? 1 : 0;
                }
                if (row >= 15 || col >= 15) return;
                const letter = e.key.toUpperCase(), rack = getCurrentRack();
                const useLetter = rack.includes(letter) ? letter : (rack.includes('?') ? '?' : null);
                if (!useLetter) { showMessage(`No "${letter}" in rack`, 'error'); return; }
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                if (useLetter === '?') {
                    rack.splice(rack.indexOf('?'), 1);
                    const tile = createTileElement(letter);
                    tile.classList.add('placed-this-turn');
                    tile.dataset.isBlank = 'true';
                    tile.dataset.placedRow = row;
                    tile.dataset.placedCol = col;
                    tile.dataset.originalLetter = '?';
                    tile.draggable = true;
                    tile.onclick = (ev) => handlePlacedTileClick(row, col, ev);
                    tile.addEventListener('dragstart', handlePlacedDragStart);
                    tile.addEventListener('dragend', handlePlacedDragEnd);
                    cell.innerHTML = '';
                    cell.appendChild(tile);
                    board[row][col] = { letter, isBlank: true };
                    placedThisTurn.push({ row, col, letter, originalLetter: '?', element: tile });
                    renderRack();
                    updateWordPreview();
                } else {
                    placeTile(letter, row, col, cell);
                }
                e.preventDefault();
            }
        });

        function handleDragStart(e) { 
            e.stopPropagation(); // Prevent click from firing
            draggedTile = e.target.closest('.tile'); 
            draggedTile.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', ''); // Required for Firefox
        }
        
        function handleDragEnd(e) { 
            if (draggedTile) draggedTile.classList.remove('dragging'); 
            draggedTile = null;
            document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
        }

        // Allow dropping back on rack to cancel
        document.getElementById('rack').addEventListener('dragover', e => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        });

        document.getElementById('rack').addEventListener('drop', e => {
            e.preventDefault();
            if (draggedPlacedTile) {
                // Return placed tile to rack
                const placement = placedThisTurn.find(p => p.row === draggedFromRow && p.col === draggedFromCol);
                if (placement) {
                    board[draggedFromRow][draggedFromCol] = null;
                    getCurrentRack().push(placement.originalLetter);
                    placedThisTurn = placedThisTurn.filter(p => p !== placement);
                    const cell = document.querySelector(`.cell[data-row="${draggedFromRow}"][data-col="${draggedFromCol}"]`);
                    restoreCell(cell, draggedFromRow, draggedFromCol);
                    renderRack();
                    updateWordPreview();
                }
                draggedPlacedTile = null;
                draggedFromRow = null;
                draggedFromCol = null;
            }
            // Dragging from rack back to rack = no-op, tile stays
            draggedTile = null;
        });

        function restoreCell(cell, row, col) {
            const type = getCellType(row, col);
            cell.innerHTML = type === 'TW' ? '<span class="premium-text">TRIPLE<br>WORD</span>' :
                type === 'DW' && !(row === 7 && col === 7) ? '<span class="premium-text">DOUBLE<br>WORD</span>' :
                type === 'TL' ? '<span class="premium-text">TRIPLE<br>LETTER</span>' :
                type === 'DL' ? '<span class="premium-text">DOUBLE<br>LETTER</span>' :
                type === 'center' ? '<span class="star">‚òÖ</span>' : '';
        }

        async function validateWord(word) {
            try { return (await (await fetch('/api/check?word=' + encodeURIComponent(word))).json()).valid; }
            catch { return true; }
        }

        function getFormedWords() {
            if (!placedThisTurn.length) return [];
            const words = [], rows = [...new Set(placedThisTurn.map(p => p.row))], cols = [...new Set(placedThisTurn.map(p => p.col))];
            const isH = rows.length === 1, isV = cols.length === 1;

            const getWord = (startR, startC, dr, dc) => {
                let word = '', positions = [], r = startR, c = startC;
                while (r >= 0 && c >= 0 && board[r][c]) { r -= dr; c -= dc; }
                r += dr; c += dc;
                while (r < 15 && c < 15 && board[r][c]) {
                    word += board[r][c].letter;
                    positions.push({ row: r, col: c, ...board[r][c], isNew: placedThisTurn.some(p => p.row === r && p.col === c) });
                    r += dr; c += dc;
                }
                return word.length > 1 ? { word, positions } : null;
            };

            if (isH || placedThisTurn.length === 1) {
                const w = getWord(placedThisTurn[0].row, Math.min(...placedThisTurn.map(p => p.col)), 0, 1);
                if (w) words.push(w);
            }
            if (isV || placedThisTurn.length === 1) {
                const w = getWord(Math.min(...placedThisTurn.map(p => p.row)), placedThisTurn[0].col, 1, 0);
                if (w && !words.some(x => x.word === w.word)) words.push(w);
            }
            placedThisTurn.forEach(({ row, col }) => {
                if (isH) { const w = getWord(row, col, 1, 0); if (w && !words.some(x => x.word === w.word && x.positions[0].col === w.positions[0].col)) words.push(w); }
                if (isV) { const w = getWord(row, col, 0, 1); if (w && !words.some(x => x.word === w.word && x.positions[0].row === w.positions[0].row)) words.push(w); }
            });
            return words;
        }

        function calculateScore(words) {
            let total = 0;
            words.forEach(({ positions }) => {
                let ws = 0, wm = 1;
                positions.forEach(p => {
                    let v = p.isBlank ? 0 : LETTER_VALUES[p.letter] || 0;
                    if (p.isNew) {
                        if (TL.some(x => x[0] === p.row && x[1] === p.col)) v *= 3;
                        else if (DL.some(x => x[0] === p.row && x[1] === p.col)) v *= 2;
                        if (TW.some(x => x[0] === p.row && x[1] === p.col)) wm *= 3;
                        else if (DW.some(x => x[0] === p.row && x[1] === p.col)) wm *= 2;
                    }
                    ws += v;
                });
                total += ws * wm;
            });
            if (placedThisTurn.length === 7) total += 50;
            return total;
        }

        async function updateWordPreview() {
            const preview = document.getElementById('word-preview'), words = getFormedWords();
            
            if (!words.length) {
                preview.innerHTML = '<span style="opacity:0.5;font-size:10px;">Place tiles</span>';
                document.getElementById('move-score').textContent = '0';
                document.getElementById('btn-play').disabled = true;
                return;
            }
            preview.innerHTML = '';
            let allValid = true;
            for (const { word } of words) {
                const chip = document.createElement('span');
                chip.className = 'word-chip';
                chip.textContent = word;
                const valid = await validateWord(word);
                chip.classList.add(valid ? 'valid' : 'invalid');
                if (!valid) allValid = false;
                preview.appendChild(chip);
            }
            document.getElementById('move-score').textContent = calculateScore(words);
            document.getElementById('btn-play').disabled = !allValid || !validatePlacement();
        }

        function validatePlacement() {
            if (!placedThisTurn.length) return false;
            const rows = [...new Set(placedThisTurn.map(p => p.row))], cols = [...new Set(placedThisTurn.map(p => p.col))];
            if (rows.length > 1 && cols.length > 1) return false;
            if (isFirstMove) return placedThisTurn.some(p => p.row === 7 && p.col === 7);
            return placedThisTurn.some(({ row, col }) =>
                [[row-1,col],[row+1,col],[row,col-1],[row,col+1]].some(([r,c]) =>
                    r >= 0 && r < 15 && c >= 0 && c < 15 && board[r][c] && !placedThisTurn.some(p => p.row === r && p.col === c)));
        }

        function showMessage(text, type = 'info') {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = 'message ' + type;
            msg.style.display = 'block';
            setTimeout(() => msg.style.display = 'none', 3000);
        }

        async function playWord() {
            const words = getFormedWords();
            log('GAME', 'Attempting to play word', { words: words.map(w => w.word), player: currentPlayer });
            for (const { word } of words) if (!(await validateWord(word))) { 
                log('GAME', 'Invalid word rejected', { word });
                showMessage(`"${word}" invalid!`, 'error'); 
                return; 
            }
            const score = calculateScore(words);
            scores[currentPlayer - 1] += score;
            
            // Track played words for Define feature
            recentlyPlayedWords = words.map(w => w.word);
            
            log('GAME', 'Word played successfully', { words: words.map(w => w.word), score, totalScore: scores[currentPlayer - 1] });
            placedThisTurn.forEach(p => p.element?.classList.remove('placed-this-turn'));
            placedThisTurn = [];
            isFirstMove = false;
            
            // Draw tiles to fill rack to 7 (with safeguard)
            const currentRack = getCurrentRack();
            const tilesToDraw = Math.max(0, 7 - currentRack.length);
            const newTiles = drawTiles(tilesToDraw);
            setCurrentRack([...currentRack, ...newTiles].slice(0, 7)); // Safeguard: max 7
            
            showMessage(`+${score} points!`, 'success');
            switchPlayer();
        }

        function recallTiles() {
            placedThisTurn.forEach(({ row, col, originalLetter }) => {
                board[row][col] = null;
                getCurrentRack().push(originalLetter);
                restoreCell(document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`), row, col);
            });
            placedThisTurn = [];
            renderRack();
            updateWordPreview();
            clearTypingMode();
        }

        function switchPlayer() {
            stopTimer();
            log('GAME', 'Switching player', { from: currentPlayer, to: currentPlayer === 1 ? 2 : 1 });
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            // Hide AI response when turn changes
            document.getElementById('ai-response-box').style.display = 'none';
            updateUI();
            if (gameMode === 'ai' && currentPlayer === 2) {
                setTimeout(doAiMove, 500);
            } else {
                startTimer();
            }
        }

        async function doAiMove() {
            document.getElementById('ai-thinking').style.display = 'flex';
            const boardData = [];
            for (let r = 0; r < 15; r++) for (let c = 0; c < 15; c++) if (board[r][c]) boardData.push({ row: r, col: c, letter: board[r][c].letter, is_blank: board[r][c].isBlank });
            
            log('AI', 'Starting AI move', { rack: getCurrentRack(), boardTiles: boardData.length });
            
            try {
                const res = await fetch('/api/ai_move', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ board: boardData, rack: getCurrentRack(), difficulty: aiDifficulty }) });
                const data = await res.json();
                
                log('AI', 'AI response received', data);
                
                document.getElementById('ai-thinking').style.display = 'none';
                if (data.success) {
                    // Validate the word client-side too
                    const wordValid = await validateWord(data.word);
                    log('AI', 'Client-side word validation', { word: data.word, valid: wordValid });
                    
                    if (!wordValid) {
                        log('AI', 'ERROR: AI returned invalid word!', { word: data.word });
                        showMessage(`AI tried invalid word: ${data.word}`, 'error');
                        switchPlayer();
                        return;
                    }
                    
                    data.tiles.forEach(tile => {
                        const cell = document.querySelector(`.cell[data-row="${tile.row}"][data-col="${tile.col}"]`);
                        cell.innerHTML = '';
                        cell.appendChild(createTileElement(tile.letter));
                        board[tile.row][tile.col] = { letter: tile.letter, isBlank: tile.is_blank };
                        const rack = getCurrentRack(), idx = tile.is_blank ? rack.indexOf('?') : rack.indexOf(tile.letter);
                        if (idx > -1) rack.splice(idx, 1);
                    });
                    scores[1] += data.score;
                    isFirstMove = false;
                    
                    // Track AI played word for Define feature
                    recentlyPlayedWords = [data.word];
                    
                    // Draw tiles to fill rack to 7 (with safeguard)
                    const aiRack = getCurrentRack();
                    const tilesToDraw = Math.max(0, 7 - aiRack.length);
                    const newTiles = drawTiles(tilesToDraw);
                    setCurrentRack([...aiRack, ...newTiles].slice(0, 7)); // Safeguard: max 7
                    
                    log('AI', 'AI move completed', { word: data.word, score: data.score, newRackSize: getCurrentRack().length });
                    
                    showMessage(`AI: "${data.word}" +${data.score}`, 'info');
                } else {
                    log('AI', 'AI passes');
                    showMessage('AI passes', 'info');
                }
                switchPlayer();
            } catch(e) { 
                log('AI', 'AI error', { error: e.message });
                document.getElementById('ai-thinking').style.display = 'none'; 
                showMessage('AI error', 'error'); 
                switchPlayer(); 
            }
        }

        let hintPreviewTiles = []; // Track hint preview tiles

        async function getHint() {
            // Clear any existing hint preview
            clearHintPreview();
            
            showMessage('Finding best move...', 'info');
            const boardData = [];
            for (let r = 0; r < 15; r++) for (let c = 0; c < 15; c++) if (board[r][c]) boardData.push({ row: r, col: c, letter: board[r][c].letter });
            try {
                const res = await fetch('/api/hint', { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ board: boardData, rack: getCurrentRack(), difficulty: 'hard' })  // Always hard for hints
                });
                const data = await res.json();
                if (data.success) {
                    // Preview tiles on board
                    previewHintOnBoard(data);
                    showMessage(`Best: "${data.word}" = ${data.score}pts (Play or Recall)`, 'success');
                } else {
                    showMessage('No moves found!', 'info');
                }
            } catch { showMessage('Hint error', 'error'); }
        }

        function previewHintOnBoard(hintData) {
            // Clear existing preview
            clearHintPreview();
            
            const rack = getCurrentRack();
            
            hintData.tiles.forEach(tile => {
                const cell = document.querySelector(`.cell[data-row="${tile.row}"][data-col="${tile.col}"]`);
                
                // Create preview tile
                const tileEl = createTileElement(tile.letter);
                tileEl.classList.add('placed-this-turn', 'hint-preview');
                tileEl.draggable = true;
                tileEl.dataset.placedRow = tile.row;
                tileEl.dataset.placedCol = tile.col;
                tileEl.dataset.originalLetter = tile.is_blank ? '?' : tile.letter;
                if (tile.is_blank) tileEl.dataset.isBlank = 'true';
                
                tileEl.onclick = (e) => handlePlacedTileClick(tile.row, tile.col, e);
                tileEl.addEventListener('dragstart', handlePlacedDragStart);
                tileEl.addEventListener('dragend', handlePlacedDragEnd);
                
                cell.innerHTML = '';
                cell.appendChild(tileEl);
                
                // Update game state
                board[tile.row][tile.col] = { letter: tile.letter, isBlank: tile.is_blank };
                
                // Remove from rack
                const rackIdx = tile.is_blank ? rack.indexOf('?') : rack.indexOf(tile.letter);
                if (rackIdx > -1) rack.splice(rackIdx, 1);
                
                // Track placement
                placedThisTurn.push({ 
                    row: tile.row, 
                    col: tile.col, 
                    letter: tile.letter, 
                    originalLetter: tile.is_blank ? '?' : tile.letter, 
                    element: tileEl 
                });
                
                hintPreviewTiles.push({ row: tile.row, col: tile.col });
            });
            
            renderRack();
            updateWordPreview();
        }

        function clearHintPreview() {
            // Remove hint preview styling (tiles stay as normal placed tiles)
            document.querySelectorAll('.tile.hint-preview').forEach(t => t.classList.remove('hint-preview'));
            hintPreviewTiles = [];
        }

        function updateUI() {
            document.getElementById('player1-score').classList.toggle('current', currentPlayer === 1);
            document.getElementById('player2-score').classList.toggle('current', currentPlayer === 2);
            document.getElementById('player1-score').querySelector('.score').textContent = scores[0];
            document.getElementById('player2-score').querySelector('.score').textContent = scores[1];
            document.getElementById('turn-indicator').textContent = currentPlayer === 1 ? 'Your turn' : (gameMode === 'ai' ? 'AI thinking...' : 'Player 2');
            document.getElementById('bag-count').textContent = bag.length;
            document.getElementById('rack-label').textContent = gameMode === 'ai' && currentPlayer === 2 ? 'AI' : 'Your Rack';
            if (gameMode === 'ai' && currentPlayer === 2) document.getElementById('rack').innerHTML = '';
            else renderRack();
            updateWordPreview();
        }

        // Global escape key to deselect
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                deselectTile();
            }
        });

        document.querySelectorAll('.mode-btn').forEach(btn => btn.addEventListener('click', () => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            gameMode = btn.dataset.mode;
            document.getElementById('difficulty').style.display = gameMode === 'ai' ? 'inline' : 'none';
            document.getElementById('player2-name').textContent = gameMode === 'ai' ? 'AI' : 'Player 2';
            initGame();
        }));

        document.getElementById('difficulty').addEventListener('change', e => aiDifficulty = e.target.value);
        document.getElementById('btn-play').addEventListener('click', playWord);
        document.getElementById('btn-recall').addEventListener('click', recallTiles);
        document.getElementById('btn-shuffle').addEventListener('click', () => { shuffleArray(getCurrentRack()); renderRack(); });
        document.getElementById('btn-hint').addEventListener('click', getHint);
        document.getElementById('btn-pass').addEventListener('click', pass);

        function pass() {
            log('GAME', 'Player passed', { player: currentPlayer });
            recallTiles();
            showMessage('Passed', 'info');
            switchPlayer();
        }

        // ============== Theme Controls ==============
        let currentBaseColor = [169, 198, 229]; // RGB - Ocean Blue default
        let currentLightness = 75; // 3/4 to dark
        let timerSeconds = 0;
        let timerInterval = null;
        let currentTimer = 0;

        // Theme presets
        const THEME_PRESETS = {
            default: {
                name: 'Ocean Blue',
                boardColor: [169, 198, 229],
                lightness: 75,
                tw: '#e06070',
                dw: '#f0a8b8',
                tl: '#40a0b0',
                dl: '#90c8e0',
                bodyBg: 'linear-gradient(145deg, #2d2d2d 0%, #1a1a1a 100%)'
            },
            sage: {
                name: 'Classic Sage',
                boardColor: [142, 142, 80],
                lightness: 50,
                tw: '#c75050',
                dw: '#d4a0a8',
                tl: '#4090a0',
                dl: '#88b8c8',
                bodyBg: 'linear-gradient(145deg, #2d2d2d 0%, #1a1a1a 100%)'
            },
            dark: {
                name: 'Dark Mode',
                boardColor: [50, 50, 50],
                lightness: 70,
                tw: '#8b3a4a',
                dw: '#6b4a50',
                tl: '#3a6a7a',
                dl: '#4a6878',
                bodyBg: 'linear-gradient(145deg, #1a1a1a 0%, #0d0d0d 100%)'
            },
            forest: {
                name: 'Forest',
                boardColor: [80, 120, 80],
                lightness: 50,
                tw: '#a04040',
                dw: '#c8a090',
                tl: '#306868',
                dl: '#70a8a0',
                bodyBg: 'linear-gradient(145deg, #1a2a1a 0%, #0d1a0d 100%)'
            },
            warm: {
                name: 'Warm Wood',
                boardColor: [180, 140, 100],
                lightness: 50,
                tw: '#b04050',
                dw: '#d8a898',
                tl: '#508080',
                dl: '#98c0b8',
                bodyBg: 'linear-gradient(145deg, #2a2018 0%, #1a1008 100%)'
            }
        };

        // Tile style presets
        const TILE_STYLES = {
            wood: {
                name: 'Classic Wood',
                face1: '#e8cdb8',
                face2: '#dfc0a8',
                face3: '#d4b090',
                face4: '#c8a078',
                border: '#a07050',
                borderLight: '#c89878',
                text: '#2a2018'
            },
            ivory: {
                name: 'Ivory',
                face1: '#f8f4e8',
                face2: '#f0ece0',
                face3: '#e8e4d8',
                face4: '#e0dcd0',
                border: '#c0b8a0',
                borderLight: '#d8d0c0',
                text: '#3a3020'
            },
            dark: {
                name: 'Dark',
                face1: '#4a4035',
                face2: '#423830',
                face3: '#3a3028',
                face4: '#322820',
                border: '#2a2018',
                borderLight: '#5a4a38',
                text: '#f0e8d8'
            },
            blue: {
                name: 'Blue',
                face1: '#b8d0e8',
                face2: '#a8c0d8',
                face3: '#98b0c8',
                face4: '#88a0b8',
                border: '#6080a0',
                borderLight: '#a0c0e0',
                text: '#1a2a3a'
            }
        };

        let currentTileStyle = 'wood';

        function applyTileStyle(styleName) {
            const style = TILE_STYLES[styleName];
            if (!style) return;
            currentTileStyle = styleName;
            
            document.documentElement.style.setProperty('--tile-face-1', style.face1);
            document.documentElement.style.setProperty('--tile-face-2', style.face2);
            document.documentElement.style.setProperty('--tile-face-3', style.face3);
            document.documentElement.style.setProperty('--tile-face-4', style.face4);
            document.documentElement.style.setProperty('--tile-border', style.border);
            document.documentElement.style.setProperty('--tile-border-light', style.borderLight);
            document.documentElement.style.setProperty('--tile-text', style.text);
        }

        // Word definition and hints - via server
        async function getWordDefinition(word) {
            try {
                const response = await fetch('/api/define', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word: word })
                });
                const data = await response.json();
                return data.definition || 'Definition not found';
            } catch (e) {
                console.error('Definition error:', e);
                return 'Could not fetch definition';
            }
        }

        async function getFunnyHint(word, rack) {
            try {
                const response = await fetch('/api/funny_hint', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word: word, rack: rack })
                });
                const data = await response.json();
                return data.hint || 'Hmm, I\'m stumped too!';
            } catch (e) {
                console.error('Hint error:', e);
                return 'My wit seems to have wandered off...';
            }
        }

        // Saved themes
        function saveCustomTheme(name) {
            const themes = JSON.parse(localStorage.getItem('scrabbleThemes') || '{}');
            themes[name] = {
                boardColor: currentBaseColor,
                lightness: currentLightness,
                tw: document.getElementById('tw-color').value,
                dw: document.getElementById('dw-color').value,
                tl: document.getElementById('tl-color').value,
                dl: document.getElementById('dl-color').value
            };
            localStorage.setItem('scrabbleThemes', JSON.stringify(themes));
            updateSavedThemesList();
            showMessage(`Theme "${name}" saved!`, 'success');
        }

        function loadCustomTheme(name) {
            const themes = JSON.parse(localStorage.getItem('scrabbleThemes') || '{}');
            if (themes[name]) {
                const t = themes[name];
                currentBaseColor = t.boardColor;
                currentLightness = t.lightness;
                document.getElementById('tw-color').value = t.tw;
                document.getElementById('dw-color').value = t.dw;
                document.getElementById('tl-color').value = t.tl;
                document.getElementById('dl-color').value = t.dl;
                document.getElementById('lightness-slider').value = t.lightness;
                const hex = '#' + t.boardColor.map(c => c.toString(16).padStart(2, '0')).join('');
                document.getElementById('board-color-picker').value = hex;
                document.getElementById('color-picker-btn').style.background = hex;
                applyPremiumColors();
                applyBoardTheme();
                showMessage(`Theme "${name}" loaded!`, 'success');
            }
        }

        function deleteCustomTheme(name) {
            const themes = JSON.parse(localStorage.getItem('scrabbleThemes') || '{}');
            delete themes[name];
            localStorage.setItem('scrabbleThemes', JSON.stringify(themes));
            updateSavedThemesList();
        }

        function updateSavedThemesList() {
            const container = document.getElementById('saved-themes-list');
            if (!container) return;
            const themes = JSON.parse(localStorage.getItem('scrabbleThemes') || '{}');
            const names = Object.keys(themes);
            if (names.length === 0) {
                container.innerHTML = '<span style="opacity:0.5;font-size:9px;">No saved themes</span>';
            } else {
                container.innerHTML = names.map(name => 
                    `<div class="saved-theme-item">
                        <span class="saved-theme-name" onclick="loadCustomTheme('${name}')">${name}</span>
                        <span class="saved-theme-delete" onclick="deleteCustomTheme('${name}')">√ó</span>
                    </div>`
                ).join('');
            }
        }

        // Settings toggle
        document.getElementById('settings-toggle').addEventListener('click', () => {
            const content = document.getElementById('settings-content');
            const arrow = document.getElementById('settings-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.classList.add('open');
            } else {
                content.style.display = 'none';
                arrow.classList.remove('open');
            }
        });

        // Theme preset buttons
        document.querySelectorAll('.theme-preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.theme-preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const preset = THEME_PRESETS[btn.dataset.theme];
                if (preset) {
                    applyThemePreset(preset);
                }
            });
        });

        function applyThemePreset(preset) {
            // Apply board color
            currentBaseColor = preset.boardColor;
            currentLightness = preset.lightness;
            
            // Update UI controls
            const hex = '#' + currentBaseColor.map(c => c.toString(16).padStart(2, '0')).join('');
            document.getElementById('board-color-picker').value = hex;
            document.getElementById('color-picker-btn').style.background = hex;
            document.getElementById('lightness-slider').value = currentLightness;
            
            // Deselect color presets, select matching one if exists
            document.querySelectorAll('.color-preset').forEach(p => {
                p.classList.remove('active');
                if (p.dataset.color === currentBaseColor.join(',')) {
                    p.classList.add('active');
                }
            });
            
            // Apply premium colors
            document.getElementById('tw-color').value = preset.tw;
            document.getElementById('dw-color').value = preset.dw;
            document.getElementById('tl-color').value = preset.tl;
            document.getElementById('dl-color').value = preset.dl;
            
            applyPremiumColors();
            applyBoardTheme();
            
            // Apply body background
            if (preset.bodyBg) {
                document.body.style.background = preset.bodyBg;
            }
        }

        // Track recently played words for Define feature
        // (recentlyPlayedWords is declared at top)

        // Define button - prompt for word or show picker
        document.getElementById('btn-define').addEventListener('click', async () => {
            // Get words from current placement
            let words = getFormedWords().map(w => w.word);
            
            // Combine with recently played
            const allWords = [...new Set([...words, ...recentlyPlayedWords])].filter(w => w.length > 0);
            
            if (allWords.length === 0) {
                const word = prompt('Enter a word to define:');
                if (!word) return;
                await showDefinition(word.toUpperCase());
            } else if (allWords.length === 1) {
                await showDefinition(allWords[0]);
            } else {
                // Multiple words - let user pick
                const word = prompt(`Which word to define?\n\n${allWords.join(', ')}`);
                if (!word) return;
                await showDefinition(word.toUpperCase());
            }
        });

        async function showDefinition(word) {
            const box = document.getElementById('ai-response-box');
            const text = document.getElementById('ai-response-text');
            box.style.display = 'block';
            text.textContent = `üìñ Looking up "${word}"...`;
            
            const definition = await getWordDefinition(word);
            text.textContent = `üìñ ${word}: ${definition}`;
        }

        // Funny Hint/Clue button - gets Scrabble AI best word, then Claude hint
        document.getElementById('btn-funny-hint').addEventListener('click', async () => {
            const rack = getCurrentRack();
            if (rack.length === 0) {
                showMessage('No tiles in rack!', 'error');
                return;
            }
            
            const box = document.getElementById('ai-response-box');
            const text = document.getElementById('ai-response-text');
            box.style.display = 'block';
            text.textContent = 'üé≠ Getting witty clue...';
            
            // First get the best word from Scrabble AI
            const boardData = [];
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (board[r][c]) {
                        boardData.push({ row: r, col: c, letter: board[r][c].letter });
                    }
                }
            }
            
            try {
                const res = await fetch('/api/hint', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ board: boardData, rack: rack, difficulty: 'hard' })
                });
                const data = await res.json();
                
                if (data.success) {
                    // Now get funny hint from Claude AI
                    const funnyHint = await getFunnyHint(data.word, rack);
                    text.textContent = `üé≠ ${funnyHint}\n\n(${data.score} pts possible)`;
                } else {
                    text.textContent = 'ü§∑ No moves found!';
                }
            } catch (e) {
                console.error('Clue error:', e);
                text.textContent = '‚ùå Could not get clue';
            }
        });

        // Tile style buttons
        document.querySelectorAll('.tile-style-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tile-style-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                applyTileStyle(btn.dataset.style);
                renderRack(); // Re-render rack with new style
            });
        });

        // Timer functions
        function applyTimerSetting() {
            timerSeconds = parseInt(document.getElementById('timer-setting').value) || 0;
            log('TIMER', 'Timer setting changed', { timerSeconds });
            showMessage(timerSeconds > 0 ? `Timer set to ${timerSeconds}s` : 'Timer disabled', 'info');
        }

        let graceMode = false;

        function startTimer() {
            if (timerSeconds <= 0) return;
            currentTimer = timerSeconds;
            graceMode = false;
            log('TIMER', 'Timer started', { currentTimer, player: currentPlayer });
            updateTimerDisplay();
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                currentTimer--;
                updateTimerDisplay();
                if (currentTimer <= 0) {
                    if (!graceMode) {
                        // Start 5 second grace period
                        graceMode = true;
                        currentTimer = 5;
                        log('TIMER', 'Grace period started', { player: currentPlayer });
                        showMessage('‚ö†Ô∏è 5 second grace period!', 'error');
                    } else {
                        // Grace period over - force pass
                        clearInterval(timerInterval);
                        timerInterval = null;
                        log('TIMER', 'Time expired - forcing pass', { player: currentPlayer });
                        showMessage('Time\'s up! Turn passed.', 'error');
                        recallTiles();
                        pass();
                    }
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                log('TIMER', 'Timer stopped');
            }
            graceMode = false;
            const timerEl = document.getElementById('timer-display');
            if (timerEl) timerEl.style.display = 'none';
        }

        function updateTimerDisplay() {
            let timerEl = document.getElementById('timer-display');
            if (!timerEl) return;
            timerEl.style.display = 'block';
            timerEl.textContent = (graceMode ? '‚ö†Ô∏è ' : '') + currentTimer + 's';
            timerEl.classList.remove('warning', 'critical', 'grace');
            if (graceMode) timerEl.classList.add('grace');
            else if (currentTimer <= 10) timerEl.classList.add('critical');
            else if (currentTimer <= 30) timerEl.classList.add('warning');
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return [h, s, l];
        }

        function applyBoardTheme() {
            const [r, g, b] = currentBaseColor;
            const [h, s, l] = rgbToHsl(r, g, b);
            
            // Adjust lightness based on slider (0-100, 50 = original)
            const lightnessAdjust = (50 - currentLightness) / 100; // -0.5 to +0.5
            const newL = Math.max(0.1, Math.min(0.9, l + lightnessAdjust));
            
            const [nr, ng, nb] = hslToRgb(h, s, newL);
            const boardColor = `rgb(${nr}, ${ng}, ${nb})`;
            
            // Slightly darker for lines
            const [lr, lg, lb] = hslToRgb(h, s, Math.max(0, newL - 0.1));
            const lineColor = `rgb(${lr}, ${lg}, ${lb})`;
            
            // Apply to CSS variables
            document.documentElement.style.setProperty('--board-bg', boardColor);
            document.documentElement.style.setProperty('--board-lines', lineColor);
            
            // Update all normal cells
            document.querySelectorAll('.cell.normal').forEach(cell => {
                cell.style.background = boardColor;
            });
        }

        function applyPremiumColors() {
            const tw = document.getElementById('tw-color').value;
            const dw = document.getElementById('dw-color').value;
            const tl = document.getElementById('tl-color').value;
            const dl = document.getElementById('dl-color').value;
            
            document.documentElement.style.setProperty('--triple-word', tw);
            document.documentElement.style.setProperty('--double-word', dw);
            document.documentElement.style.setProperty('--triple-letter', tl);
            document.documentElement.style.setProperty('--double-letter', dl);
            document.documentElement.style.setProperty('--center-bg', dw);
            
            // Update existing cells
            document.querySelectorAll('.cell.TW').forEach(c => c.style.background = tw);
            document.querySelectorAll('.cell.DW').forEach(c => c.style.background = dw);
            document.querySelectorAll('.cell.TL').forEach(c => c.style.background = tl);
            document.querySelectorAll('.cell.DL').forEach(c => c.style.background = dl);
            document.querySelectorAll('.cell.center').forEach(c => c.style.background = dw);
            
            // Update labels
            document.querySelector('.premium-label.tw').style.background = tw;
            document.querySelector('.premium-label.dw').style.background = dw;
            document.querySelector('.premium-label.tl').style.background = tl;
            document.querySelector('.premium-label.dl').style.background = dl;
        }

        // Color preset clicks
        document.querySelectorAll('.color-preset').forEach(preset => {
            preset.addEventListener('click', () => {
                document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
                preset.classList.add('active');
                
                const rgb = preset.dataset.color.split(',').map(Number);
                currentBaseColor = rgb;
                
                // Update color picker to match
                const hex = '#' + rgb.map(c => c.toString(16).padStart(2, '0')).join('');
                document.getElementById('board-color-picker').value = hex;
                document.getElementById('color-picker-btn').style.background = hex;
                
                applyBoardTheme();
            });
        });

        // Custom color picker
        document.getElementById('board-color-picker').addEventListener('input', (e) => {
            const hex = e.target.value;
            document.getElementById('color-picker-btn').style.background = hex;
            
            // Parse hex to RGB
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            currentBaseColor = [r, g, b];
            
            // Deselect presets
            document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
            
            applyBoardTheme();
        });

        // Lightness slider
        document.getElementById('lightness-slider').addEventListener('input', (e) => {
            currentLightness = parseInt(e.target.value);
            applyBoardTheme();
        });

        // Premium color pickers
        ['tw', 'dw', 'tl', 'dl'].forEach(type => {
            document.getElementById(`${type}-color`).addEventListener('input', applyPremiumColors);
        });

        function initGame() {
            debugLog = []; // Clear log on new game
            log('GAME', 'Initializing new game');
            board = Array(15).fill(null).map(() => Array(15).fill(null));
            scores = [0, 0]; currentPlayer = 1; placedThisTurn = []; isFirstMove = true;
            initBag();
            log('GAME', 'Bag initialized', { bagCount: bag.length });
            initBoard();
            
            const rack1 = drawTiles(7);
            const rack2 = drawTiles(7);
            log('GAME', 'Drew tiles', { rack1: rack1, rack2: rack2, bagAfter: bag.length });
            
            racks = [rack1, rack2];
            log('GAME', 'Racks assigned', { racks0: racks[0], racks1: racks[1] });
            
            recentlyPlayedWords = [];
            updateUI();
            updateSavedThemesList();
            applyBoardTheme(); // Apply default darker color
            
            log('GAME', 'Game initialized complete', { rack1: racks[0], rack2: racks[1], bagCount: bag.length });
        }

        initGame();
    </script>
</body>
</html>
