<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>Scrabble</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.6.1/socket.io.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            /* Blue board theme - DEFAULT */
            --board-bg: rgb(169, 198, 229);
            --board-lines: rgb(149, 178, 209);
            --triple-word: #e06070;
            --triple-word-text: #fff;
            --double-word: #f0a8b8;
            --double-word-text: #5a3038;
            --triple-letter: #40a0b0;
            --triple-letter-text: #fff;
            --double-letter: #90c8e0;
            --double-letter-text: #284858;
            --center-bg: #f0a8b8;
            --center-star: #c05068;
            --frame-dark: #5c4a3a;
            --frame-mid: #7a6352;
            --frame-light: #96806c;
            --frame-accent: #c9a227;
            --tile-border: #a07050;
            --tile-border-light: #c89878;
            --tile-face-1: #e8cdb8;
            --tile-face-2: #dfc0a8;
            --tile-face-3: #d4b090;
            --tile-face-4: #c8a078;
            --tile-text: #2a2018;
            --text-light: #f5f0e6;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(145deg, #2d2d2d 0%, #1a1a1a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            color: var(--text-light);
            touch-action: manipulation; /* Disable double-tap zoom, allow pinch */
            overscroll-behavior: none; /* Prevent scroll bounce/chaining */
        }
        
        html {
            overscroll-behavior: none;
        }

        h1 {
            color: var(--frame-accent);
            font-size: 1.8rem;
            letter-spacing: 6px;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .mode-selector-inline {
            display: flex;
            gap: 4px;
            margin-top: 4px;
        }

        .mode-btn {
            flex: 1;
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: transparent;
            color: var(--text-light);
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn:hover, .mode-btn.active {
            background: var(--frame-accent);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
            flex-wrap: nowrap;
            min-width: max-content; /* Prevent shrinking */
        }

        .board-section {
            position: relative;
            flex-shrink: 0;
            flex-grow: 0;
        }

        .timer-display {
            position: absolute;
            top: -45px;
            right: 0;
            background: rgba(0,0,0,0.85);
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 20px;
            font-weight: bold;
            color: #4ade80;
            display: none;
            border: 2px solid rgba(255,255,255,0.1);
            z-index: 100;
        }

        .timer-display.warning {
            color: #fbbf24;
            border-color: rgba(251,191,36,0.3);
        }

        .timer-display.critical {
            color: #ef4444;
            border-color: rgba(239,68,68,0.3);
            animation: timer-pulse 0.5s ease infinite;
        }

        .timer-display.grace {
            color: #ef4444;
            background: rgba(239,68,68,0.2);
            border-color: #ef4444;
            animation: timer-pulse 0.3s ease infinite;
        }

        @keyframes timer-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* RIGHT PANEL - FIXED SIZE, NO MOVEMENT */
        .rack-panel {
            display: flex;
            flex-direction: column;
            width: 320px;
            height: 540px; /* Fixed height to match board */
            flex-shrink: 0;
            flex-grow: 0;
            background: rgba(0,0,0,0.25);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid rgba(255,255,255,0.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            gap: 6px;
        }

        /* AI RESPONSE BOX - FIXED SIZE AT TOP */
        .ai-response-box {
            background: rgba(30, 25, 40, 0.8);
            border: 1px solid rgba(100, 80, 140, 0.5);
            border-radius: 6px;
            height: 130px; /* Slightly taller */
            flex-shrink: 0;
            overflow: hidden;
        }

        .ai-response-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 3px 8px;
            background: rgba(0,0,0,0.3);
            font-size: 9px;
            font-weight: 600;
        }

        .clear-btn {
            background: none;
            border: none;
            color: #aaa;
            font-size: 12px;
            cursor: pointer;
            padding: 0 4px;
        }

        .clear-btn:hover {
            color: #fff;
        }

        .ai-response-text {
            padding: 6px 8px;
            font-size: 11px;
            line-height: 1.8; /* Double spacing */
            height: calc(100% - 22px);
            overflow-y: auto;
            color: #e8e0f0;
        }

        /* SMALL BUTTONS ROW */
        .rack-buttons-row {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        .rack-buttons-row .btn {
            flex: 1;
            padding: 5px 4px;
            font-size: 9px;
        }

        .define-btn {
            background: linear-gradient(145deg, #5a7a5a, #3a5a3a);
        }

        .define-btn:hover {
            background: linear-gradient(145deg, #7a9a7a, #4a6a4a);
        }

        /* ACTION BUTTONS - COMPACT */
        .btn-group-vertical {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex-grow: 1;
        }

        .btn-group-vertical .btn {
            width: 100%;
            padding: 6px;
            font-size: 11px;
        }

        /* CLASSIC SCRABBLE RACK - FIXED AT BOTTOM */
        .rack-frame-horizontal {
            background: linear-gradient(145deg, var(--frame-light), var(--frame-mid) 50%, var(--frame-dark));
            padding: 10px 8px;
            border-radius: 8px;
            box-shadow: 
                0 4px 12px rgba(0,0,0,0.4), 
                inset 0 1px 0 rgba(255,255,255,0.15),
                inset 0 -2px 4px rgba(0,0,0,0.2);
            margin-top: auto; /* Push to bottom */
            flex-shrink: 0;
        }

        .rack-frame-horizontal .rack-label {
            font-size: 9px;
            margin-bottom: 6px;
            text-align: center;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .rack-frame-horizontal .rack {
            display: flex;
            flex-direction: row;
            gap: 4px;
            min-height: 50px;
            justify-content: center;
            align-items: center;
        }

        /* CLASSIC SQUARE SCRABBLE TILES */
        .rack-frame-horizontal .rack .tile {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        .rack-frame-horizontal .rack .tile:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        .rack-frame-horizontal .rack .tile.selected {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.5), 0 0 0 3px var(--frame-accent);
        }

        /* Rack drag-to-reorder styles */
        .rack-frame-horizontal .rack .tile.rack-ghost {
            opacity: 0.3;
            transform: scale(0.9);
        }

        /* Floating clone - appended to body so needs global selector */
        .tile.rack-dragging {
            position: fixed !important;
            z-index: 10000 !important;
            transform: scale(1.5);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2), 0 0 0 2px #00ffff;
            opacity: 0.5;  /* Desktop: 50% opacity */
            pointer-events: none;
            transition: none;
            background: var(--tile-bg, linear-gradient(145deg, #f5deb3, #deb887));
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Mobile: more translucent and larger */
        body.mobile .tile.rack-dragging {
            opacity: 0.4;
            transform: scale(1.8);
        }

        .rack-insertion-line {
            position: fixed;
            width: 4px;
            height: 48px;
            background: linear-gradient(180deg, #00ff88, #00ffff, #00ff88);
            border-radius: 2px;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 0 10px #00ff88, 0 0 20px #00ffff, 0 0 30px #00ff88;
            animation: insertion-pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes insertion-pulse {
            from { opacity: 0.8; transform: scaleY(0.95); }
            to { opacity: 1; transform: scaleY(1.05); }
        }

        /* Tiles spread apart during drag */
        .rack-frame-horizontal .rack .tile.shift-left {
            transform: translateX(-12px);
            transition: transform 0.12s ease-out;
        }

        .rack-frame-horizontal .rack .tile.shift-right {
            transform: translateX(12px);
            transition: transform 0.12s ease-out;
        }
        
        .rack-frame-horizontal .rack .tile {
            transition: transform 0.12s ease-out;
        }

        .rack-frame-horizontal .rack .tile .letter {
            font-size: 22px;
            pointer-events: none;
        }

        .rack-frame-horizontal .rack .tile .points {
            font-size: 8px;
            pointer-events: none;
        }

        .debug-btn {
            background: rgba(100,100,100,0.3);
            border-color: #666;
            font-size: 9px;
            padding: 4px;
            flex-shrink: 0;
        }

        .debug-btn:hover {
            background: rgba(100,100,100,0.5);
        }

        .board-frame {
            /* Wood grain texture on frame */
            background: 
                repeating-linear-gradient(
                    92deg,
                    transparent 0px,
                    transparent 2px,
                    rgba(0,0,0,0.03) 2px,
                    rgba(0,0,0,0.03) 3px
                ),
                repeating-linear-gradient(
                    88deg,
                    transparent 0px,
                    transparent 4px,
                    rgba(255,255,255,0.02) 4px,
                    rgba(255,255,255,0.02) 5px
                ),
                linear-gradient(145deg, #4a3a2a, #3a2a1a 50%, #2a1a0a);
            padding: 18px;
            border-radius: 8px;
            position: relative;
            
            /* 3D raised effect - thicker and more defined */
            box-shadow: 
                /* Outer glow/shadow */
                0 16px 40px rgba(0,0,0,0.6),
                0 10px 25px rgba(0,0,0,0.5),
                /* Thick bottom/right edge */
                5px 5px 0 #3a2a1a,
                8px 8px 0 #2a1a0a,
                10px 10px 0 #1a0a00,
                12px 12px 0 #100500,
                /* Far shadow */
                15px 25px 35px rgba(0,0,0,0.5);
            
            /* Dark border for definition */
            border: 3px solid #1a0a00;
        }

        /* Top bevel - light hitting the top edge */
        .board-frame::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 8px;
            background: linear-gradient(to bottom, 
                rgba(255,255,255,0.25) 0%, 
                rgba(255,255,255,0.1) 40%,
                transparent 100%);
            border-radius: 8px 8px 0 0;
            pointer-events: none;
        }

        /* Left bevel - light hitting the left edge */
        .board-frame::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 12px;
            width: 6px;
            background: linear-gradient(to right, 
                rgba(255,255,255,0.2) 0%, 
                rgba(255,255,255,0.08) 40%,
                transparent 100%);
            border-radius: 8px 0 0 8px;
            pointer-events: none;
        }

        .board-inner {
            background: var(--board-lines);
            padding: 3px;
            border-radius: 4px;
            position: relative;
            /* Recessed playing surface */
            box-shadow: 
                inset 0 4px 12px rgba(0,0,0,0.5),
                inset 0 2px 6px rgba(0,0,0,0.4),
                inset 4px 0 10px rgba(0,0,0,0.25),
                /* Outer lip catch light */
                0 1px 0 rgba(255,255,255,0.12),
                1px 0 0 rgba(255,255,255,0.06);
            border: 2px solid rgba(0,0,0,0.3);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(15, 32px);
            gap: 2px;
        }

        .cell {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4px;
            font-weight: 700;
            text-transform: uppercase;
            line-height: 1.1;
            text-align: center;
            border-radius: 1px;
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
            touch-action: manipulation;
        }

        .cell.normal { background: var(--board-bg); }
        .cell.DL { background: var(--double-letter); color: var(--double-letter-text); }
        .cell.TL { background: var(--triple-letter); color: var(--triple-letter-text); }
        .cell.DW { background: var(--double-word); color: var(--double-word-text); }
        .cell.TW { background: var(--triple-word); color: var(--triple-word-text); }
        .cell.center { background: var(--center-bg); }
        .cell.center .star { font-size: 14px; color: var(--center-star); pointer-events: none; }

        .cell.selected {
            box-shadow: inset 0 0 0 2px var(--frame-accent), 0 0 10px rgba(201,162,39,0.5);
        }

        .cell.drag-hover {
            box-shadow: inset 0 0 0 3px #00ffff, 0 0 25px #00ffff, 0 0 40px rgba(0,255,255,1);
            transition: all 0.1s ease;
            z-index: 50;
        }

        /* Rack-to-board: Bold BLACK border highlight */
        .cell.drag-magnify {
            transform: scale(1.15);
            z-index: 100;
            box-shadow: inset 0 0 0 4px #000000 !important;
            outline: 3px solid #000000;
            background: rgba(255,255,255,0.3) !important;
        }
        
        /* Board-to-board: 1.4x scale with bold BLACK border (mobile) */
        body.mobile .cell.drag-board-target {
            transform: scale(1.4);
            z-index: 100;
            box-shadow: inset 0 0 0 4px #000000 !important;
            outline: 3px solid #000000;
            background: rgba(255,255,255,0.3) !important;
        }

        /* Board-to-board: 15% bigger with MAX brightness */
        .cell.drag-board-target {
            transform: scale(1.15);
            z-index: 100;
            box-shadow: inset 0 0 0 4px #00ffff, 0 0 35px #00ffff, 0 0 60px rgba(0,255,255,1);
        }

        .cell.typing-start {
            box-shadow: inset 0 0 0 3px #4ade80;
        }

        .cell .premium-text {
            font-size: 4px;
            font-weight: 700;
            line-height: 1.1;
            pointer-events: none;
        }

        .tile {
            width: 28px;
            height: 28px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: grab;
            user-select: none;
            background: linear-gradient(160deg, var(--tile-border-light), var(--tile-border));
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            z-index: 10;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .tile::before {
            content: '';
            position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            border-radius: 2px;
            background: 
                repeating-linear-gradient(95deg, transparent 0px, transparent 3px, rgba(160,120,80,0.08) 3px, rgba(160,120,80,0.08) 4px),
                linear-gradient(165deg, var(--tile-face-1), var(--tile-face-2) 30%, var(--tile-face-3) 70%, var(--tile-face-4));
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.7), inset 0 -1px 2px rgba(0,0,0,0.1);
        }

        .tile .letter {
            position: relative;
            z-index: 2;
            font-size: 16px;
            font-weight: 700;
            color: var(--tile-text);
            pointer-events: none;
        }

        .tile .points {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 6px;
            font-weight: 600;
            color: var(--tile-text);
            z-index: 2;
            pointer-events: none;
        }

        .tile.selected {
            transform: scale(1.1);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 3px var(--frame-accent);
        }

        .tile.placed-this-turn {
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 2px var(--frame-accent);
            cursor: pointer;
        }

        .tile.dragging { opacity: 0.7; cursor: grabbing; }

        /* Hint preview tiles */
        .tile.hint-preview {
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 2px #4ade80, 0 0 12px rgba(74,222,128,0.4);
            animation: hint-pulse 1.5s ease infinite;
        }

        @keyframes hint-pulse {
            0%, 100% { box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 2px #4ade80, 0 0 12px rgba(74,222,128,0.4); }
            50% { box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 3px #4ade80, 0 0 20px rgba(74,222,128,0.6); }
        }

        /* Floating tile that follows cursor */
        .tile.floating {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%) scale(1.15);
            box-shadow: 4px 6px 12px rgba(0,0,0,0.5), 0 0 0 3px var(--frame-accent);
        }

        /* Direction arrow indicator */
        .direction-arrow {
            position: absolute;
            font-size: 18px;
            color: #4ade80;
            z-index: 5;
            text-shadow: 0 0 4px rgba(74,222,128,0.8);
            animation: pulse 1s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .cell.can-drop {
            background: rgba(74,222,128,0.3) !important;
        }

        .rack-area { display: flex; flex-direction: column; gap: 10px; }

        .rack-row {
            display: flex;
            align-items: stretch;
            gap: 10px;
        }

        .rack-buttons {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .hint-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 12px;
            font-size: 11px;
            gap: 4px;
            white-space: nowrap;
        }

        .clue-btn {
            background: linear-gradient(145deg, #6a5a8a, #4a3a6a);
        }

        .clue-btn:hover {
            background: linear-gradient(145deg, #8a7aaa, #5a4a7a);
        }

        .rack-frame {
            background: linear-gradient(145deg, var(--frame-light), var(--frame-dark));
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .rack-label {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 5px;
            text-align: center;
        }

        .rack {
            background: var(--frame-mid);
            padding: 6px 8px;
            border-radius: 4px;
            display: flex;
            gap: 4px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.4);
            min-width: 240px;
            min-height: 42px;
            justify-content: center;
            align-items: center;
        }

        .btn-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(145deg, var(--frame-light), var(--frame-dark));
            color: var(--text-light);
            border: 1px solid var(--frame-mid);
            padding: 8px 14px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn.primary {
            background: linear-gradient(145deg, var(--frame-accent), #a68520);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .new-game-btn {
            width: 100%;
            background: linear-gradient(145deg, #8b4513, #5a2d0a);
            border-color: #cd853f;
            margin-bottom: 6px;
            padding: 6px 10px;
        }

        .new-game-btn:hover:not(:disabled) {
            background: linear-gradient(145deg, #a0522d, #8b4513);
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            font-size: 10px;
            opacity: 0.8;
        }

        .ai-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #666;
            flex-shrink: 0;
        }

        .ai-status.thinking .ai-dot {
            background: #4ade80;
            animation: pulse-dot 1s ease infinite;
        }

        .ai-status.thinking .ai-status-text {
            color: #4ade80;
        }

        @keyframes pulse-dot {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 160px;
        }

        .info-box {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .bag-count-display {
            text-align: center;
            opacity: 0.6;
            font-size: 11px;
        }

        .info-box h3 {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 2px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 13px;
        }

        .score-row.current { color: var(--frame-accent); }
        .score-row .score { 
            font-weight: 700; 
            font-size: 20px;
            color: #fff;
        }
        .score-row.current .score {
            color: var(--frame-accent);
            text-shadow: 0 0 8px rgba(200, 160, 100, 0.5);
        }

        .word-preview {
            min-height: 24px;
            max-height: 50px;
            overflow-y: auto;
            display: flex;
            align-items: flex-start;
            gap: 4px;
            flex-wrap: wrap;
        }

        .word-chip {
            background: rgba(255,255,255,0.1);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
        }

        .word-chip.valid { background: rgba(46,160,67,0.3); color: #4ade80; }
        .word-chip.invalid { background: rgba(220,38,38,0.3); color: #f87171; }

        .message {
            text-align: center;
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .message.error { background: rgba(220,38,38,0.2); color: #f87171; }
        .message.success { background: rgba(46,160,67,0.2); color: #4ade80; }
        .message.info { background: rgba(59,130,246,0.2); color: #60a5fa; }

        .typing-input { position: fixed; top: -100px; opacity: 0; }

        .keyboard-hint {
            font-size: 10px;
            opacity: 0.6;
            text-align: center;
            padding: 5px;
        }

        .ai-thinking {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            padding: 10px;
            color: var(--frame-accent);
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--frame-mid);
            border-top-color: var(--frame-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        
        @keyframes disintegrate {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.1); }
            100% { opacity: 0; transform: scale(0.5); }
        }
        
        .tile.shake {
            animation: shake 0.5s ease-in-out;
            box-shadow: 0 0 10px #ff0000, inset 0 0 5px #ff0000 !important;
        }
        
        .tile.disintegrate {
            animation: disintegrate 0.4s ease-out forwards;
        }

        .difficulty-select {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: var(--frame-dark);
            color: var(--text-light);
            font-size: 11px;
        }

        /* Theme Controls */
        .settings-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.05);
            overflow: hidden;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: background 0.2s;
        }

        .settings-header:hover {
            background: rgba(255,255,255,0.05);
        }

        .settings-arrow {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .settings-arrow.open {
            transform: rotate(180deg);
        }

        .settings-content {
            padding: 0 12px 12px;
        }

        .settings-section {
            margin-bottom: 12px;
        }

        .settings-section h4 {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .theme-presets {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
        }

        .theme-preset-btn {
            flex: 1;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: transparent;
            color: var(--text-light);
            font-size: 9px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .theme-preset-btn:hover, .theme-preset-btn.active {
            background: var(--frame-accent);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .theme-panel h3 {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 2px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .theme-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .theme-row label {
            font-size: 10px;
            min-width: 45px;
            opacity: 0.8;
        }

        .color-presets {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .color-preset {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .color-preset:hover {
            transform: scale(1.1);
        }

        .color-preset.active {
            border-color: var(--frame-accent);
            box-shadow: 0 0 8px rgba(201,162,39,0.5);
        }

        .theme-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: linear-gradient(to right, #1a1a1a, #888, #fff);
            outline: none;
        }

        .theme-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--frame-accent);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .theme-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--frame-accent);
            cursor: pointer;
            border: none;
        }

        .color-picker-wrap {
            position: relative;
        }

        .color-picker-btn {
            width: 26px;
            height: 26px;
            border-radius: 4px;
            border: 2px solid var(--frame-mid);
            cursor: pointer;
            overflow: hidden;
        }

        .color-picker-btn input {
            position: absolute;
            width: 40px;
            height: 40px;
            top: -6px;
            left: -6px;
            cursor: pointer;
            opacity: 0;
        }

        .premium-colors {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .premium-color-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .premium-label {
            font-size: 8px;
            font-weight: 700;
            padding: 2px 4px;
            border-radius: 2px;
            min-width: 22px;
            text-align: center;
        }

        .premium-label.tw { background: #e06070; color: #fff; }
        .premium-label.dw { background: #f0a8b8; color: #5a3038; }
        .premium-label.tl { background: #40a0b0; color: #fff; }
        .premium-label.dl { background: #90c8e0; color: #284858; }

        .premium-picker {
            width: 28px;
            height: 20px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            padding: 0;
        }

        .save-theme-row {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }

        .theme-name-input {
            flex: 1;
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: rgba(0,0,0,0.3);
            color: var(--text-light);
            font-size: 10px;
        }

        .btn-small {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: var(--frame-dark);
            color: var(--text-light);
            font-size: 9px;
            cursor: pointer;
        }

        .btn-small:hover {
            background: var(--frame-accent);
            color: #1a1a1a;
        }

        .saved-themes-list {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 80px;
            overflow-y: auto;
        }

        .saved-theme-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 8px;
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }

        .saved-theme-name {
            font-size: 10px;
            cursor: pointer;
        }

        .saved-theme-name:hover {
            color: var(--frame-accent);
        }

        .saved-theme-delete {
            font-size: 14px;
            cursor: pointer;
            opacity: 0.5;
        }

        .saved-theme-delete:hover {
            opacity: 1;
            color: #e85a70;
        }

        .tile-style-btn {
            flex: 1;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: transparent;
            color: var(--text-light);
            font-size: 9px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tile-style-btn:hover, .tile-style-btn.active {
            background: var(--frame-accent);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .timer-input {
            width: 60px;
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: rgba(0,0,0,0.3);
            color: var(--text-light);
            font-size: 11px;
            text-align: center;
        }

        /* Word tools */
        .word-tools {
            display: flex;
            gap: 6px;
            margin-top: 6px;
        }

        .word-tool-btn {
            flex: 1;
            padding: 6px 8px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: rgba(0,0,0,0.3);
            color: var(--text-light);
            font-size: 9px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .word-tool-btn:hover {
            background: var(--frame-accent);
            color: #1a1a1a;
        }

        .word-tool-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .definition-box {
            margin-top: 8px;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            font-size: 10px;
            line-height: 1.4;
            display: none;
        }

        .definition-box.visible {
            display: block;
        }

        .definition-word {
            color: var(--frame-accent);
            font-weight: 600;
            margin-bottom: 4px;
        }

        /* MOBILE STYLES */
        body.mobile .game-container {
            flex-direction: column;
            align-items: center;
            padding: 10px;
            gap: 6px;
        }

        /* Mobile: Score/Turn/Words at TOP */
        body.mobile .side-panel {
            order: 1;
            width: 100%;
            max-width: 500px;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 4px;
            padding: 4px 8px;
        }

        body.mobile .side-panel .info-box {
            flex: 1;
            min-width: 60px;
            padding: 6px;
        }

        body.mobile .side-panel .info-box h3 {
            font-size: 7px;
            margin-bottom: 4px;
        }

        /* Hide some elements on mobile to save space */
        body.mobile .side-panel .settings-panel,
        body.mobile .side-panel .ai-status,
        body.mobile .side-panel .new-game-btn,
        body.mobile .side-panel .bag-count-display,
        body.mobile .side-panel > .info-box:last-of-type {
            display: none;
        }

        /* Make side panel more compact on mobile */
        body.mobile .side-panel .score-row {
            font-size: 11px;
            padding: 2px 0;
        }

        body.mobile .side-panel .score-row .score {
            font-size: 14px;
        }

        body.mobile #turn-indicator {
            font-size: 10px !important;
        }

        body.mobile .word-preview {
            font-size: 9px;
        }

        body.mobile .board-section {
            order: 2;
            width: 100%;
            max-width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
        }

        /* Smaller board on mobile to fit screen */
        body.mobile .board {
            grid-template-columns: repeat(15, min(6vw, 28px));
            gap: 1px;
            max-width: calc(100vw - 20px);
        }
        
        body.mobile .cell {
            width: min(6vw, 28px);
            height: min(6vw, 28px);
            font-size: 3px;
        }
        
        body.mobile .cell .tile {
            width: calc(min(6vw, 28px) - 2px);
            height: calc(min(6vw, 28px) - 2px);
        }
        
        body.mobile .cell .tile .letter {
            font-size: min(3.5vw, 14px);
        }
        
        body.mobile .cell .tile .points {
            font-size: min(1.5vw, 6px);
            bottom: 1px;
            right: 1px;
        }
        
        body.mobile .cell.center .star {
            font-size: min(3vw, 12px);
        }
        
        body.mobile .cell .premium-text {
            font-size: min(1vw, 3px);
        }

        body.mobile .rack-panel {
            order: 3;
            width: 100%;
            max-width: 500px;
            height: auto;
            flex-direction: column;
            gap: 6px;
            padding: 8px;
        }

        /* Mobile: Rack FIRST */
        body.mobile .rack-frame-horizontal {
            order: 1;
            margin-top: 0;
        }

        /* Mobile: Play buttons below rack */
        body.mobile .rack-panel .btn-group-vertical {
            order: 2;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: center;
            gap: 4px;
        }

        body.mobile .rack-panel .btn-group-vertical .btn {
            width: auto;
            padding: 8px 12px;
            flex: 1;
            min-width: 60px;
        }

        /* Mobile: Hint/Clue/Define buttons */
        body.mobile .rack-panel .rack-buttons-row {
            order: 3;
            width: 100%;
            justify-content: center;
        }

        /* Mobile: AI response at bottom - TRIPLE SIZE */
        body.mobile .rack-panel .ai-response-box {
            order: 4;
            width: 100%;
            height: 200px;
        }

        body.mobile .rack-panel .ai-response-box .ai-response-text {
            height: calc(200px - 30px);
            max-height: calc(200px - 30px);
        }

        body.mobile .rack-frame-horizontal .rack {
            justify-content: center;
        }

        /* ============== iPad/Tablet Optimizations ============== */
        /* Tablet gets mobile layout (rack under board) but with larger board */
        body.tablet .board {
            grid-template-columns: repeat(15, min(5.5vw, 42px));
            gap: 2px;
        }
        
        body.tablet .cell {
            width: min(5.5vw, 42px);
            height: min(5.5vw, 42px);
            font-size: 4px;
        }
        
        body.tablet .cell .tile {
            width: calc(min(5.5vw, 42px) - 2px);
            height: calc(min(5.5vw, 42px) - 2px);
        }
        
        body.tablet .cell .tile .letter {
            font-size: min(3.2vw, 20px);
        }
        
        body.tablet .cell .tile .points {
            font-size: min(1.2vw, 8px);
            bottom: 2px;
            right: 2px;
        }
        
        body.tablet .cell.center .star {
            font-size: min(2.8vw, 18px);
        }
        
        body.tablet .cell .premium-text {
            font-size: min(0.9vw, 5px);
        }
        
        body.tablet .rack-panel {
            max-width: 650px;
        }
        
        body.tablet .rack-frame-horizontal {
            padding: 12px;
        }
        
        body.tablet .rack .tile {
            width: 46px;
            height: 46px;
        }
        
        body.tablet .rack .tile .letter {
            font-size: 22px;
        }
        
        body.tablet .rack .tile .points {
            font-size: 9px;
        }
        
        body.tablet .rack-panel .ai-response-box {
            height: 180px;
        }
        
        body.tablet .rack-panel .ai-response-box .ai-response-text {
            height: calc(180px - 30px);
            max-height: calc(180px - 30px);
            font-size: 15px;
        }

        /* ============== Multiplayer Lobby Styles ============== */
        .lobby-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.95);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        .lobby-overlay.hidden {
            display: none;
        }
        
        .lobby-container {
            background: linear-gradient(145deg, #3d3d3d 0%, #2a2a2a 100%);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            border: 2px solid var(--frame-accent);
        }
        
        .lobby-title {
            font-size: 28px;
            color: var(--frame-accent);
            text-align: center;
            margin-bottom: 20px;
            letter-spacing: 3px;
        }
        
        .lobby-section {
            margin-bottom: 20px;
        }
        
        .lobby-section h3 {
            color: var(--text-light);
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .lobby-input {
            width: 100%;
            padding: 12px 15px;
            font-size: 16px;
            border: 2px solid #555;
            border-radius: 8px;
            background: #222;
            color: var(--text-light);
            margin-bottom: 10px;
        }
        
        .lobby-input:focus {
            outline: none;
            border-color: var(--frame-accent);
        }
        
        .lobby-input.room-code {
            text-transform: uppercase;
            letter-spacing: 8px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }
        
        .lobby-btn {
            width: 100%;
            padding: 14px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 10px;
        }
        
        .lobby-btn.primary {
            background: linear-gradient(135deg, var(--frame-accent) 0%, #a08020 100%);
            color: #1a1a1a;
        }
        
        .lobby-btn.secondary {
            background: linear-gradient(135deg, #4a4a4a 0%, #3a3a3a 100%);
            color: var(--text-light);
            border: 2px solid #666;
        }
        
        .lobby-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .lobby-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .lobby-divider {
            text-align: center;
            color: #666;
            margin: 20px 0;
            position: relative;
        }
        
        .lobby-divider::before,
        .lobby-divider::after {
            content: '';
            position: absolute;
            top: 50%;
            width: 40%;
            height: 1px;
            background: #444;
        }
        
        .lobby-divider::before { left: 0; }
        .lobby-divider::after { right: 0; }
        
        .lobby-back {
            color: #888;
            text-align: center;
            cursor: pointer;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .lobby-back:hover {
            color: var(--frame-accent);
        }
        
        /* Waiting room */
        .room-code-display {
            background: #1a1a1a;
            border: 3px solid var(--frame-accent);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .room-code-display .label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }
        
        .room-code-display .code {
            font-size: 36px;
            font-weight: bold;
            color: var(--frame-accent);
            letter-spacing: 10px;
        }
        
        .player-list {
            background: #222;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }
        
        .player-list-title {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }
        
        .player-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }
        
        .player-item:last-child {
            border-bottom: none;
        }
        
        .player-item .player-icon {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--frame-accent);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-weight: bold;
            color: #1a1a1a;
        }
        
        .player-item .player-name {
            color: var(--text-light);
            flex: 1;
        }
        
        .player-item .player-host {
            font-size: 10px;
            background: var(--frame-accent);
            color: #1a1a1a;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
        }
        
        .player-item .player-score {
            color: var(--frame-accent);
            font-weight: bold;
            font-size: 18px;
        }
        
        .waiting-message {
            text-align: center;
            color: #888;
            font-size: 14px;
            animation: pulse 2s ease-in-out infinite;
        }
        
        /* Multiplayer game indicator */
        .multiplayer-indicator {
            display: none;
            background: linear-gradient(135deg, #2a5a2a 0%, #1a3a1a 100%);
            border: 2px solid #4a8a4a;
            border-radius: 8px;
            padding: 8px 15px;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .multiplayer-indicator.active {
            display: block;
        }
        
        .multiplayer-indicator .room-info {
            font-size: 12px;
            color: #8a8;
        }
        
        .multiplayer-indicator .room-code-small {
            font-weight: bold;
            color: #4a8;
            letter-spacing: 2px;
        }
        
        /* Your turn indicator */
        .your-turn-indicator {
            display: none;
            background: linear-gradient(135deg, var(--frame-accent) 0%, #a08020 100%);
            color: #1a1a1a;
            font-weight: bold;
            padding: 10px;
            text-align: center;
            border-radius: 8px;
            animation: pulse 1s ease-in-out infinite;
        }
        
        .your-turn-indicator.active {
            display: block;
        }
        
        /* Mobile footer - only visible on mobile */
        .mobile-footer {
            display: none;
        }

        body.mobile .mobile-footer {
            display: flex;
            order: 5;
            width: 100%;
            max-width: 500px;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            gap: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            margin-top: 6px;
        }

        .new-game-btn-mobile {
            background: linear-gradient(145deg, #8b4513, #5a2d0a);
            border-color: #cd853f;
            padding: 8px 16px;
            font-size: 11px;
        }

        .new-game-btn-mobile:hover {
            background: linear-gradient(145deg, #a0522d, #8b4513);
        }

        .mobile-ai-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }

        .difficulty-select-mobile {
            background: rgba(0,0,0,0.4);
            color: var(--text-light);
            border: 1px solid var(--frame-mid);
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 11px;
        }

        /* NO RESPONSIVE CHANGES FOR DESKTOP */
    </style>
</head>
<body>
    <!-- Multiplayer Lobby Overlay -->
    <div id="lobby-overlay" class="lobby-overlay hidden">
        <!-- Main Menu - First Choice -->
        <div id="lobby-main" class="lobby-container">
            <h1 class="lobby-title"> SCRABBLE</h1>
            
            <div class="lobby-section">
                <h3>Your Name</h3>
                <input type="text" id="player-name-input" class="lobby-input" placeholder="Enter your name" maxlength="15" value="">
            </div>
            
            <button id="btn-play-ai" class="lobby-btn primary"> Play vs AI</button>
            
            <div class="lobby-divider">or</div>
            
            <button id="btn-multiplayer" class="lobby-btn secondary"> Multiplayer</button>
            
            <div id="rejoin-section" style="display:none; margin-top:15px;">
                <div class="lobby-divider">saved game</div>
                <button id="btn-rejoin" class="lobby-btn" style="background:#2d5a27;"> Rejoin Room <span id="rejoin-code">----</span></button>
                <button id="btn-clear-saved" style="background:transparent; border:none; color:#888; font-size:11px; margin-top:5px; cursor:pointer;"> Clear saved game</button>
            </div>
            
            <div id="lobby-status" style="margin-top:15px; padding:10px; background:#1a1a1a; border-radius:8px; font-size:12px; color:#888; text-align:center; min-height:40px;">
                Ready to play...
            </div>
        </div>
        
        <!-- Multiplayer Menu -->
        <div id="lobby-menu" class="lobby-container" style="display:none;">
            <h1 class="lobby-title"> MULTIPLAYER</h1>
            
            <button id="btn-create-room" class="lobby-btn primary"> Create Room</button>
            
            <div class="lobby-divider">or join existing</div>
            
            <div class="lobby-section">
                <h3>Room Code</h3>
                <input type="text" id="room-code-input" class="lobby-input room-code" placeholder="CODE" maxlength="4">
            </div>
            
            <button id="btn-join-room" class="lobby-btn secondary">Join Game</button>
            <button id="btn-join-board" class="lobby-btn secondary"> Join as Display Board</button>
            
            <div class="lobby-back" id="btn-back-main"> Back</div>
            
            <div id="lobby-status-mp" style="margin-top:15px; padding:10px; background:#1a1a1a; border-radius:8px; font-size:12px; color:#888; text-align:center; min-height:40px;">
                Ready to connect...
            </div>
        </div>
        
        <!-- Waiting Room -->
        <div id="lobby-waiting" class="lobby-container" style="display:none;">
            <h1 class="lobby-title"> WAITING</h1>
            
            <div class="room-code-display">
                <div class="label">Room Code</div>
                <div class="code" id="display-room-code">----</div>
            </div>
            
            <div class="player-list">
                <div class="player-list-title">Players (<span id="player-count">0</span>/4)</div>
                <div id="player-list-items">
                    <!-- Players will be added here -->
                </div>
            </div>
            
            <p class="waiting-message" id="waiting-message">Waiting for players...</p>
            
            <button id="btn-start-game" class="lobby-btn primary" style="display:none;"> Start Game</button>
            
            <div class="lobby-back" id="btn-leave-room"> Leave Room</div>
        </div>
        
        <!-- Board View (iPad) -->
        <div id="lobby-board-view" class="lobby-container" style="display:none;">
            <h1 class="lobby-title"> DISPLAY BOARD</h1>
            <p style="color:#888;text-align:center;margin-bottom:15px;">Connected as spectator board</p>
            <div class="room-code-display">
                <div class="label">Room Code</div>
                <div class="code" id="display-room-code-board">----</div>
            </div>
            <p class="waiting-message">Waiting for game to start...</p>
            <div class="lobby-back" id="btn-leave-board"> Leave</div>
        </div>
    </div>

    <div class="game-container">
        <div class="side-panel">
            <button class="btn new-game-btn" id="btn-new-game"> New Game</button>
            <div class="ai-status" id="ai-status">
                <span class="ai-dot"></span>
                <span class="ai-status-text">Ready</span>
            </div>
            
            <div class="info-box">
                <h3>Score</h3>
                <div class="score-row current" id="player1-score">
                    <span id="player1-name">You</span>
                    <span class="score">0</span>
                </div>
                <div class="score-row" id="player2-score">
                    <span id="player2-name">AI</span>
                    <span class="score">0</span>
                </div>
            </div>

            <div class="info-box">
                <h3>Turn</h3>
                <div id="turn-indicator" style="font-size:12px;">Your turn</div>
            </div>

            <div class="info-box">
                <h3>Words</h3>
                <div class="word-preview" id="word-preview">
                    <span style="opacity:0.5;font-size:10px;">Place tiles</span>
                </div>
            </div>

            <div class="info-box">
                <h3>Move</h3>
                <div class="score-row">
                    <span>Points</span>
                    <span class="score" id="move-score">0</span>
                </div>
            </div>

            <div class="bag-count-display">
                Bag: <strong id="bag-count">86</strong>
            </div>

            <div class="settings-panel">
                <div class="settings-header" id="settings-toggle">
                    <span> Settings</span>
                    <span class="settings-arrow" id="settings-arrow"></span>
                </div>
                <div class="settings-content" id="settings-content" style="display:none;">
                    <div class="settings-section">
                        <h4>Theme Presets</h4>
                        <div class="theme-presets">
                            <button class="theme-preset-btn active" data-theme="default">Ocean</button>
                            <button class="theme-preset-btn" data-theme="sage">Sage</button>
                            <button class="theme-preset-btn" data-theme="dark">Dark</button>
                            <button class="theme-preset-btn" data-theme="forest">Forest</button>
                            <button class="theme-preset-btn" data-theme="warm">Warm</button>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h4>Tile Style</h4>
                        <div class="theme-presets">
                            <button class="tile-style-btn active" data-style="wood">Wood</button>
                            <button class="tile-style-btn" data-style="ivory">Ivory</button>
                            <button class="tile-style-btn" data-style="dark">Dark</button>
                            <button class="tile-style-btn" data-style="blue">Blue</button>
                        </div>
                    </div>
                    
                    <div class="settings-section">
                        <h4>Board Color</h4>
                        <div class="color-presets" id="color-presets">
                            <div class="color-preset active" data-color="169,198,229" style="background:rgb(169,198,229);" title="Ocean"></div>
                            <div class="color-preset" data-color="142,142,80" style="background:#8e8e50;" title="Sage"></div>
                            <div class="color-preset" data-color="80,120,80" style="background:#507850;" title="Forest"></div>
                            <div class="color-preset" data-color="180,140,100" style="background:#b48c64;" title="Warm"></div>
                            <div class="color-preset" data-color="50,50,50" style="background:#323232;" title="Dark"></div>
                        </div>
                        <div class="theme-row">
                            <label>Custom</label>
                            <div class="color-picker-wrap">
                                <div class="color-picker-btn" id="color-picker-btn" style="background:rgb(169,198,229);">
                                    <input type="color" id="board-color-picker" value="#a9c6e5">
                                </div>
                            </div>
                        </div>
                        <div class="theme-row">
                            <label>Light</label>
                            <input type="range" class="theme-slider" id="lightness-slider" min="0" max="100" value="75">
                            <label style="min-width:auto;">Dark</label>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h4>Premium Squares</h4>
                        <div class="premium-colors">
                            <div class="premium-color-row">
                                <span class="premium-label tw">TW</span>
                                <input type="color" class="premium-picker" id="tw-color" value="#e06070">
                            </div>
                            <div class="premium-color-row">
                                <span class="premium-label dw">DW</span>
                                <input type="color" class="premium-picker" id="dw-color" value="#f0a8b8">
                            </div>
                            <div class="premium-color-row">
                                <span class="premium-label tl">TL</span>
                                <input type="color" class="premium-picker" id="tl-color" value="#40a0b0">
                            </div>
                            <div class="premium-color-row">
                                <span class="premium-label dl">DL</span>
                                <input type="color" class="premium-picker" id="dl-color" value="#90c8e0">
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h4>Timer (seconds, 0=off)</h4>
                        <div class="theme-row">
                            <input type="number" id="timer-setting" class="timer-input" value="0" min="0" max="300" step="10">
                            <button class="btn-small" onclick="applyTimerSetting()">Set</button>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h4>Save Theme</h4>
                        <div class="save-theme-row">
                            <input type="text" id="theme-name-input" placeholder="Theme name..." class="theme-name-input">
                            <button class="btn-small" onclick="saveCustomTheme(document.getElementById('theme-name-input').value)">Save</button>
                        </div>
                        <div class="saved-themes-list" id="saved-themes-list">
                            <span style="opacity:0.5;font-size:9px;">No saved themes</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="info-box" style="margin-top:auto;">
                <h3>Game Mode</h3>
                <div class="mode-selector-inline">
                    <button class="mode-btn" data-mode="2player">2 Player</button>
                    <button class="mode-btn active" data-mode="ai">vs AI</button>
                </div>
                <select class="difficulty-select" id="difficulty" style="width:100%;margin-top:6px;">
                    <option value="easy">Easy</option>
                    <option value="medium">Medium</option>
                    <option value="hard" selected>Hard</option>
                </select>
            </div>
        </div>

        <div class="board-section">
            <div class="timer-display" id="timer-display"></div>
            <div class="board-frame">
                <div class="board-inner">
                    <div class="board" id="board"></div>
                </div>
            </div>
        </div>

        <div class="rack-panel">
            <div class="ai-response-box" id="ai-response-box">
                <div class="ai-response-header">
                    <span> AI Response</span>
                    <button class="clear-btn" onclick="document.getElementById('ai-response-text').textContent='Click Hint, Clue, or Define...';"></button>
                </div>
                <div class="ai-response-text" id="ai-response-text">Click Hint, Clue, or Define...</div>
            </div>
            
            <div class="rack-buttons-row">
                <button class="btn hint-btn" id="btn-hint" title="Show best move"> Hint</button>
                <button class="btn hint-btn clue-btn" id="btn-funny-hint" title="Get witty clue"> Clue</button>
                <button class="btn hint-btn define-btn" id="btn-define" title="Define a word"> Define</button>
            </div>

            <div class="btn-group-vertical">
                <button class="btn primary" id="btn-play">Play</button>
                <button class="btn" id="btn-recall">Recall</button>
                <button class="btn" id="btn-shuffle">Shuffle</button>
                <button class="btn" id="btn-pass">Pass</button>
            </div>

            <div class="rack-frame-horizontal">
                <div class="rack-label" id="rack-label">Your Rack</div>
                <div class="rack" id="rack"></div>
            </div>

            <div id="message" class="message" style="display:none;"></div>
            <div id="ai-thinking" class="ai-thinking" style="display:none;">
                <div class="spinner"></div>
                <span>AI thinking...</span>
            </div>

            <button class="btn debug-btn" id="btn-debug" title="Export debug log"> Debug Log</button>
        </div>
        
        <!-- Mobile-only footer -->
        <div class="mobile-footer">
            <button class="btn new-game-btn-mobile" id="btn-new-game-mobile"> New Game</button>
            <div class="mobile-ai-controls">
                <span>AI Level:</span>
                <select class="difficulty-select-mobile" id="difficulty-mobile">
                    <option value="easy">Easy</option>
                    <option value="medium">Medium</option>
                    <option value="hard" selected>Hard</option>
                </select>
            </div>
        </div>
    </div>

    <input type="text" class="typing-input" id="typing-input" autocomplete="off">
    <div class="tile floating" id="floating-tile" style="display:none;">
        <span class="letter"></span>
        <span class="points"></span>
    </div>

    <script>
        const BOARD_SIZE = 15;
        const LETTER_VALUES = {A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10,'?':0};
        const TILE_COUNTS = {A:9,B:2,C:2,D:4,E:12,F:2,G:3,H:2,I:9,J:1,K:1,L:4,M:2,N:6,O:8,P:2,Q:1,R:6,S:4,T:6,U:4,V:2,W:2,X:1,Y:2,Z:1,'?':2};
        
        // Mobile/Tablet detection - iPad should use mobile layout (rack under board)
        const isIPhone = /iPhone|iPod/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);
        // iPadOS 13+ reports as "Macintosh" but has touch support
        const isIPad = /iPad/i.test(navigator.userAgent) || 
                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) ||
                       (/Macintosh/i.test(navigator.userAgent) && 'ontouchend' in document);
        const isSmallScreen = window.innerWidth < 768;
        const isMobile = isIPhone || isAndroid || isIPad || isSmallScreen;
        
        if (isMobile) {
            document.body.classList.add('mobile');
            console.log('[DEVICE] Mobile layout enabled', { isIPhone, isAndroid, isIPad, isSmallScreen });
        }
        if (isIPad) {
            document.body.classList.add('tablet');
            console.log('[DEVICE] iPad detected - using tablet optimizations');
        }
        const TW = [[0,0],[0,7],[0,14],[7,0],[7,14],[14,0],[14,7],[14,14]];
        const DW = [[1,1],[2,2],[3,3],[4,4],[1,13],[2,12],[3,11],[4,10],[13,1],[12,2],[11,3],[10,4],[13,13],[12,12],[11,11],[10,10],[7,7]];
        const TL = [[1,5],[1,9],[5,1],[5,5],[5,9],[5,13],[9,1],[9,5],[9,9],[9,13],[13,5],[13,9]];
        const DL = [[0,3],[0,11],[2,6],[2,8],[3,0],[3,7],[3,14],[6,2],[6,6],[6,8],[6,12],[7,3],[7,11],[8,2],[8,6],[8,8],[8,12],[11,0],[11,7],[11,14],[12,6],[12,8],[14,3],[14,11]];

        let board = Array(15).fill(null).map(() => Array(15).fill(null));
        let bag = [], currentPlayer = 1, scores = [0, 0];
        let racks = [[], []], placedThisTurn = [], isFirstMove = true;
        let selectedTile = null, selectedLetter = null, typingCell = null, typingDirection = null;
        let gameMode = 'ai', aiDifficulty = 'hard', draggedTile = null;
        let floatingTile = null;
        let recentlyPlayedWords = [];
        let wordHistory = []; // Last 10 scored words
        let turnStartTiles = []; // Tiles at start of turn - for recovery!
        let isValidatingTiles = false; // Prevent recursive validation

        // ============== Multiplayer State ==============
        let socket = null;
        let multiplayerMode = false;
        let roomCode = null;
        let playerId = null;
        let playerName = 'Player';
        let isHost = false;
        let isBoardViewer = false;  // iPad board-only mode
        let isMyTurn = false;
        let allPlayers = [];  // [{id, name, score}]
        let currentPlayerIdx = 0;

        // Rack drag-to-reorder state
        let rackDrag = {
            active: false,
            tile: null,
            tileIndex: -1,
            letter: null, // Store the letter being dragged!
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            insertIndex: -1,
            threshold: 10, // pixels before drag activates
            insertionLine: null,
            floatingClone: null,
            highlightedCells: [], // Array for 9-square magnification on mobile
            completed: false // Prevent double-processing
        };

        // Placed tile drag state (for moving tiles on board)
        let placedDrag = {
            active: false,
            tile: null,
            fromRow: -1,
            fromCol: -1,
            letter: null,
            originalLetter: null,
            isBlank: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            floatingClone: null,
            highlightedCell: null
        };

        // Flag to disable validation during game initialization
        let isInitializingGame = false;

        // Debug logging system
        let debugLog = [];
        const MAX_LOG_ENTRIES = 500;

        function log(category, message, data = null) {
            const timestamp = new Date().toISOString();
            const entry = { timestamp, category, message, data };
            debugLog.push(entry);
            if (debugLog.length > MAX_LOG_ENTRIES) debugLog.shift();
            console.log(`[${category}] ${message}`, data || '');
        }

        // ============== Tile Count Protection ==============
        function saveTurnStartTiles() {
            const rack = getCurrentRack();
            // ABSOLUTE LIMIT: Scrabble racks can NEVER have more than 7 tiles
            const maxTiles = Math.min(rack.length, 7);
            turnStartTiles = rack.slice(0, maxTiles);
            
            if (rack.length > 7) {
                log('ERROR', 'Rack exceeded 7 tiles! Forcing to 7.', { had: rack.length });
                // Also truncate the actual rack!
                rack.length = 7;
            }
            
            log('TILES', 'Saved turn start tiles', { tiles: [...turnStartTiles], count: turnStartTiles.length });
        }

        // SAFE rack modification - validates immediately!
        function safeRemoveFromRack(letter) {
            const rack = getCurrentRack();
            const idx = rack.indexOf(letter);
            if (idx === -1) {
                log('ERROR', 'safeRemoveFromRack: letter not found!', { letter, rack: [...rack] });
                return false;
            }
            rack.splice(idx, 1);
            log('RACK', 'Safe removed tile', { letter, rackAfter: [...rack] });
            
            // INSTANT validation
            validateAndRecoverTiles();
            return true;
        }

        function validateAndRecoverTiles() {
            // CRITICAL: Skip validation during game initialization
            if (isInitializingGame) {
                return true;
            }
            
            // Safety check: turnStartTiles should NEVER exceed 7
            if (turnStartTiles.length > 7) {
                log('ERROR', 'turnStartTiles corrupted! Resetting.', { count: turnStartTiles.length });
                turnStartTiles = getCurrentRack().slice(0, 7);
                return true;
            }
            
            // If no turn started yet, skip validation
            if (turnStartTiles.length === 0) {
                return true;
            }
            
            // What we SHOULD have = turnStartTiles
            // What we ACTUALLY have = rack + placedThisTurn
            const expected = [...turnStartTiles].sort();
            const onBoard = placedThisTurn.map(p => p.originalLetter);
            const inRack = [...getCurrentRack()];
            const actual = [...onBoard, ...inRack].sort();
            
            if (actual.length === expected.length && actual.join(',') === expected.join(',')) {
                return true; // All good!
            }
            
            // Safety: if actual is already MORE than expected, something is very wrong - don't add more!
            if (actual.length >= expected.length) {
                return true;
            }
            
            // Something's wrong - find missing tiles
            const expectedCounts = {};
            const actualCounts = {};
            
            expected.forEach(l => expectedCounts[l] = (expectedCounts[l] || 0) + 1);
            actual.forEach(l => actualCounts[l] = (actualCounts[l] || 0) + 1);
            
            const missing = [];
            for (const letter in expectedCounts) {
                const diff = expectedCounts[letter] - (actualCounts[letter] || 0);
                for (let i = 0; i < diff; i++) {
                    missing.push(letter);
                }
            }
            
            if (missing.length > 0) {
                // Safety: never recover if it would give us more than 7 tiles
                const rack = getCurrentRack();
                const wouldHave = rack.length + onBoard.length + missing.length;
                if (wouldHave > 7) {
                    log('ERROR', 'Recovery would exceed 7 tiles! Skipping.', { wouldHave, missing });
                    return true;
                }
                
                log('RECOVERY', 'TILES MISSING - recovering!', { 
                    missing, 
                    expected: [...turnStartTiles], 
                    onBoard: [...onBoard], 
                    inRack: [...inRack] 
                });
                
                // Add missing tiles back to rack
                missing.forEach(letter => rack.push(letter));
                renderRack();
                
                log('RECOVERY', 'Tiles restored', { rackAfter: [...rack] });
                return false; // Had to recover
            }
            
            return true;
        }

        function exportDebugLog() {
            const gameState = {
                board: board.map((row, r) => row.map((cell, c) => cell ? { letter: cell.letter, isBlank: cell.isBlank } : null)),
                scores: scores,
                currentPlayer: currentPlayer,
                racks: racks,
                bagCount: bag.length,
                gameMode: gameMode,
                aiDifficulty: aiDifficulty,
                timerSettings: { timerSeconds, currentTimer, graceMode }
            };

            let content = '=== SCRABBLE DEBUG LOG ===\n';
            content += `Exported: ${new Date().toISOString()}\n`;
            content += `User Agent: ${navigator.userAgent}\n\n`;
            
            content += '=== GAME STATE ===\n';
            content += JSON.stringify(gameState, null, 2) + '\n\n';
            
            content += '=== EVENT LOG ===\n';
            debugLog.forEach(entry => {
                content += `[${entry.timestamp}] [${entry.category}] ${entry.message}`;
                if (entry.data) content += ' | ' + JSON.stringify(entry.data);
                content += '\n';
            });

            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `scrabble-debug-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showMessage('Debug log exported!', 'success');
        }

        // Add debug button handler
        document.addEventListener('DOMContentLoaded', () => {
            const debugBtn = document.getElementById('btn-debug');
            if (debugBtn) debugBtn.addEventListener('click', exportDebugLog);
        });

        function initBag() {
            bag = [];
            for (let letter in TILE_COUNTS) {
                for (let i = 0; i < TILE_COUNTS[letter]; i++) bag.push(letter);
            }
            log('GAME', 'Bag populated before shuffle', { bagLength: bag.length, first10: bag.slice(0, 10) });
            shuffleArray(bag);
            log('GAME', 'Bag after shuffle', { bagLength: bag.length });
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function drawTiles(n) { 
            const drawn = bag.splice(0, Math.min(n, bag.length)); 
            log('GAME', 'drawTiles called', { requested: n, drawn: [...drawn], drawnCount: drawn.length, bagRemaining: bag.length });
            return drawn;
        }
        function getCurrentRack() { return racks[currentPlayer - 1]; }
        function setCurrentRack(r) { racks[currentPlayer - 1] = r; }

        function getCellType(r, c) {
            if (r === 7 && c === 7) return 'center';
            if (TW.some(p => p[0] === r && p[1] === c)) return 'TW';
            if (DW.some(p => p[0] === r && p[1] === c)) return 'DW';
            if (TL.some(p => p[0] === r && p[1] === c)) return 'TL';
            if (DL.some(p => p[0] === r && p[1] === c)) return 'DL';
            return 'normal';
        }

        // ============== Rack Drag-to-Reorder ==============
        function initRackDrag(tile, x, y, tileIndex) {
            rackDrag.tile = tile;
            rackDrag.tileIndex = tileIndex;
            rackDrag.letter = tile.dataset.letter; // Store letter immediately!
            rackDrag.startX = x;
            rackDrag.startY = y;
            rackDrag.currentX = x;
            rackDrag.currentY = y;
            rackDrag.active = false;
            rackDrag.insertIndex = -1;
            rackDrag.completed = false;
        }

        function activateRackDrag() {
            if (rackDrag.active) return;
            rackDrag.active = true;
            
            // Clear any tile selection
            if (selectedTile) {
                selectedTile.classList.remove('selected');
                selectedTile = null;
                selectedLetter = null;
            }
            
            const tile = rackDrag.tile;
            const rect = tile.getBoundingClientRect();
            
            // Make original tile a ghost (faded placeholder)
            tile.classList.add('rack-ghost');
            tile.classList.remove('selected');
            
            // Create floating clone
            rackDrag.floatingClone = tile.cloneNode(true);
            rackDrag.floatingClone.classList.add('rack-dragging');
            rackDrag.floatingClone.classList.remove('rack-ghost', 'selected');
            rackDrag.floatingClone.style.left = rect.left + 'px';
            rackDrag.floatingClone.style.top = rect.top + 'px';
            rackDrag.floatingClone.style.width = rect.width + 'px';
            rackDrag.floatingClone.style.height = rect.height + 'px';
            document.body.appendChild(rackDrag.floatingClone);
            
            // Create insertion line
            rackDrag.insertionLine = document.createElement('div');
            rackDrag.insertionLine.className = 'rack-insertion-line';
            rackDrag.insertionLine.style.display = 'none';
            document.body.appendChild(rackDrag.insertionLine);
            
            log('INPUT', 'Rack drag activated', { tileIndex: rackDrag.tileIndex });
        }

        function updateRackDrag(x, y) {
            if (!rackDrag.tile) return;
            
            rackDrag.currentX = x;
            rackDrag.currentY = y;
            
            // Check if we've moved enough to activate drag
            const dx = x - rackDrag.startX;
            const dy = y - rackDrag.startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (!rackDrag.active && distance > rackDrag.threshold) {
                activateRackDrag();
            }
            
            if (!rackDrag.active) return;
            
            // Move floating CLONE 
            // Mobile: float above finger so user can see the board below
            // Desktop: slightly above finger
            const clone = rackDrag.floatingClone;
            if (clone) {
                if (isMobile) {
                    // Float above finger so user can see board
                    clone.style.left = (x - 25) + 'px';
                    clone.style.top = (y - 60) + 'px';  // Above finger
                } else {
                    // Desktop: slightly above
                    clone.style.left = (x - 20) + 'px';
                    clone.style.top = (y - 30) + 'px';
                }
            }
            
            // Find insertion position based on x position
            const rackEl = document.getElementById('rack');
            const rackRect = rackEl.getBoundingClientRect();
            // Use ALL tiles including ghost for gap detection
            const allTiles = Array.from(rackEl.querySelectorAll('.tile'));
            
            let insertIdx = -1;
            
            // Check if we're over the rack area
            if (y > rackRect.top - 80 && y < rackRect.bottom + 80) {
                // Find which GAP we're near
                // Allow all gaps - we'll filter invalid moves at drop time
                const gapThreshold = 22; // pixels from gap center to trigger
                
                for (let i = 0; i <= allTiles.length; i++) {
                    let gapX;
                    if (i === 0 && allTiles[0]) {
                        // Gap before first tile
                        const r = allTiles[0].getBoundingClientRect();
                        gapX = r.left - 2;
                    } else if (i === allTiles.length && allTiles[allTiles.length - 1]) {
                        // Gap after last tile
                        const r = allTiles[allTiles.length - 1].getBoundingClientRect();
                        gapX = r.right + 2;
                    } else if (i > 0 && i < allTiles.length && allTiles[i - 1] && allTiles[i]) {
                        // Gap between tiles[i-1] and tiles[i]
                        const prevR = allTiles[i - 1].getBoundingClientRect();
                        const nextR = allTiles[i].getBoundingClientRect();
                        gapX = (prevR.right + nextR.left) / 2;
                    }
                    
                    if (gapX && Math.abs(x - gapX) < gapThreshold) {
                        insertIdx = i;
                        break;
                    }
                }
            }
            
            // Only show insertion line for VALID moves (different from current position)
            const isValidMove = insertIdx >= 0 && 
                                insertIdx !== rackDrag.tileIndex && 
                                insertIdx !== rackDrag.tileIndex + 1;
            
            if (isValidMove) {
                rackDrag.insertIndex = insertIdx;
                
                // Show bright insertion line (both mobile and desktop)
                let lineX;
                
                if (insertIdx === 0 && allTiles[0]) {
                    const r = allTiles[0].getBoundingClientRect();
                    lineX = r.left - 3;
                } else if (insertIdx >= allTiles.length && allTiles[allTiles.length - 1]) {
                    const r = allTiles[allTiles.length - 1].getBoundingClientRect();
                    lineX = r.right + 1;
                } else if (allTiles[insertIdx - 1]) {
                    const r = allTiles[insertIdx - 1].getBoundingClientRect();
                    lineX = r.right + 1;
                }
                
                if (lineX && rackDrag.insertionLine) {
                    rackDrag.insertionLine.style.left = lineX + 'px';
                    rackDrag.insertionLine.style.top = (rackRect.top - 2) + 'px';
                    rackDrag.insertionLine.style.display = 'block';
                }
                
                // Desktop: Spread tiles apart to show insertion point
                if (!isMobile) {
                    allTiles.forEach((t, i) => {
                        t.classList.remove('shift-left', 'shift-right');
                        if (t.classList.contains('rack-ghost')) return; // Skip dragged tile
                        
                        // Tiles before insertion shift left, tiles after shift right
                        if (i < insertIdx && i >= rackDrag.tileIndex) {
                            // These tiles are between old pos and new pos (moving right)
                            t.classList.add('shift-left');
                        } else if (i >= insertIdx && i < rackDrag.tileIndex) {
                            // These tiles are between new pos and old pos (moving left)
                            t.classList.add('shift-right');
                        }
                    });
                }
            } else {
                rackDrag.insertIndex = -1;
                if (rackDrag.insertionLine) {
                    rackDrag.insertionLine.style.display = 'none';
                }
                // Clear tile shifts
                allTiles.forEach(t => t.classList.remove('shift-left', 'shift-right'));
            }
            
            // Check if TILE (not finger!) is over BOARD - magnify cells
            const boardEl = document.getElementById('board');
            const boardRect = boardEl.getBoundingClientRect();
            
            // Clear previous magnified cells
            rackDrag.highlightedCells.forEach(c => {
                c.classList.remove('drag-hover', 'drag-magnify');
            });
            rackDrag.highlightedCells = [];
            
            // Calculate TILE position for board detection
            // Mobile: detect cell ABOVE touch point (north of fingertip)
            // Desktop: detect cell slightly above finger
            let tileCenterX, tileCenterY;
            if (isMobile) {
                tileCenterX = x;
                tileCenterY = y - 40; // ABOVE finger - north of fingertip
            } else {
                tileCenterX = x;
                tileCenterY = y - 10; // Slightly above finger
            }
            
            if (tileCenterX >= boardRect.left && tileCenterX <= boardRect.right && 
                tileCenterY >= boardRect.top && tileCenterY <= boardRect.bottom) {
                
                // Find which cell the TILE is over
                const element = document.elementFromPoint(tileCenterX, tileCenterY);
                const cell = element?.closest('.cell');
                
                if (cell) {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    // Check if cell is valid (empty or has tile placed this turn)
                    const isOccupied = board[row][col];
                    const placedHere = placedThisTurn.find(p => p.row === row && p.col === col);
                    
                    if (!isOccupied || placedHere) {
                        // Highlight single target cell (both mobile and desktop)
                        cell.classList.add('drag-hover', 'drag-magnify');
                        rackDrag.highlightedCells.push(cell);
                    }
                }
                
                // Hide insertion line when over board
                if (rackDrag.insertionLine) {
                    rackDrag.insertionLine.style.display = 'none';
                }
            }
        }

        function endRackDrag() {
            // Prevent double-processing (touch events can fire multiple times)
            if (!rackDrag.tile || rackDrag.completed) return;
            rackDrag.completed = true; // Mark as being processed
            
            const wasActive = rackDrag.active;
            const tile = rackDrag.tile;
            const letter = rackDrag.letter; // Use stored letter, NOT DOM lookup
            const toIndex = rackDrag.insertIndex;
            const x = rackDrag.currentX;
            const y = rackDrag.currentY;
            
            // Clean up visual state - remove ghost from original
            if (tile) tile.classList.remove('rack-ghost');
            
            // Remove floating clone
            if (rackDrag.floatingClone) {
                rackDrag.floatingClone.remove();
                rackDrag.floatingClone = null;
            }
            
            // Remove insertion line
            if (rackDrag.insertionLine) {
                rackDrag.insertionLine.remove();
                rackDrag.insertionLine = null;
            }
            
            // Clear tile shift animations
            document.querySelectorAll('.tile.shift-left, .tile.shift-right').forEach(t => {
                t.classList.remove('shift-left', 'shift-right');
            });
            
            // Remove cell highlight and magnify
            rackDrag.highlightedCells.forEach(c => {
                c.classList.remove('drag-hover', 'drag-magnify');
            });
            rackDrag.highlightedCells = [];
            
            // Helper to reset state
            const resetDragState = () => {
                rackDrag.tile = null;
                rackDrag.tileIndex = -1;
                rackDrag.letter = null;
                rackDrag.active = false;
                rackDrag.insertIndex = -1;
                rackDrag.completed = false;
            };
            
            if (!wasActive) {
                // Was just a tap, not a drag - selection already handled
                resetDragState();
                return;
            }
            
            const rack = getCurrentRack();
            
            // Find current position of this letter in rack
            const currentIdx = rack.indexOf(letter);
            if (currentIdx === -1) {
                log('ERROR', 'Drag ended but letter not in rack!', { letter, rack: [...rack] });
                resetDragState();
                return;
            }
            
            // Check if TILE (not finger!) dropped on a BOARD CELL
            const boardEl = document.getElementById('board');
            const boardRect = boardEl.getBoundingClientRect();
            
            // Calculate TILE position for board detection
            // Mobile: detect cell ABOVE touch point (north of fingertip)
            // Desktop: detect cell slightly above finger
            let tileCenterX, tileCenterY;
            if (isMobile) {
                tileCenterX = x;
                tileCenterY = y - 40; // ABOVE finger - north of fingertip
            } else {
                tileCenterX = x;
                tileCenterY = y - 10;
            }
            
            if (tileCenterX >= boardRect.left && tileCenterX <= boardRect.right && 
                tileCenterY >= boardRect.top && tileCenterY <= boardRect.bottom) {
                
                // Find which cell the TILE is over
                const element = document.elementFromPoint(tileCenterX, tileCenterY);
                const cell = element?.closest('.cell');
                
                if (cell) {
                    // Remove magnify classes first
                    cell.classList.remove('drag-hover', 'drag-magnify');
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    
                    // Check if cell is valid (empty or has tile placed this turn)
                    const isOccupied = board[row][col];
                    const placedHere = placedThisTurn.find(p => p.row === row && p.col === col);
                    
                    if (!isOccupied || placedHere) {
                        // If there's a tile placed this turn, return it first
                        if (placedHere) {
                            returnPlacedTile(row, col);
                        }
                        
                        // Handle blank tile
                        if (letter === '?') {
                            const choice = prompt('Blank tile! Enter letter (A-Z):');
                            if (choice && /^[A-Za-z]$/.test(choice)) {
                                placeTile(choice.toUpperCase(), row, col, cell, true);
                                rack.splice(currentIdx, 1);
                                renderRack();
                                updateMoveScore();
                                animateTileDrop(cell);
                                log('INPUT', 'Drag-dropped blank tile on board', { letter: choice.toUpperCase(), row, col });
                            }
                        } else {
                            placeTile(letter, row, col, cell);
                            rack.splice(currentIdx, 1);
                            renderRack();
                            updateMoveScore();
                            animateTileDrop(cell);
                            log('INPUT', 'Drag-dropped tile on board', { letter, row, col, rackAfter: [...rack] });
                        }
                        
                        resetDragState();
                        return;
                    }
                }
            }
            
            // Check if we should REORDER within rack
            if (toIndex >= 0 && toIndex !== currentIdx && toIndex !== currentIdx + 1) {
                // Calculate final position
                let insertAt = toIndex;
                if (insertAt > currentIdx) insertAt--; // Adjust because we'll remove first
                
                // Clamp to valid range
                insertAt = Math.max(0, Math.min(insertAt, rack.length - 1));
                
                // Remove from current position
                rack.splice(currentIdx, 1);
                
                // Insert at new position
                rack.splice(insertAt, 0, letter);
                
                log('INPUT', 'Rack reordered', { from: currentIdx, to: insertAt, letter, rackAfter: [...rack] });
                
                // Re-render rack (includes instant validation)
                renderRack();
            }
            
            resetDragState();
        }
        
        // Drop animation for tile placement
        function animateTileDrop(cell) {
            const tile = cell.querySelector('.tile');
            if (tile) {
                tile.style.transform = 'scale(1.2)';
                tile.style.transition = 'transform 0.15s ease-out';
                setTimeout(() => {
                    tile.style.transform = 'scale(1)';
                }, 150);
            }
        }

        function cancelRackDrag() {
            if (!rackDrag.tile) return;
            
            const tile = rackDrag.tile;
            if (tile) tile.classList.remove('rack-ghost');
            
            // Remove floating clone
            if (rackDrag.floatingClone) {
                rackDrag.floatingClone.remove();
                rackDrag.floatingClone = null;
            }
            
            if (rackDrag.insertionLine) {
                rackDrag.insertionLine.remove();
                rackDrag.insertionLine = null;
            }
            
            // Clear tile shift animations
            document.querySelectorAll('.tile.shift-left, .tile.shift-right').forEach(t => {
                t.classList.remove('shift-left', 'shift-right');
            });
            
            // Remove cell highlight and magnify
            rackDrag.highlightedCells.forEach(c => {
                c.classList.remove('drag-hover', 'drag-magnify');
            });
            rackDrag.highlightedCells = [];
            
            rackDrag.tile = null;
            rackDrag.tileIndex = -1;
            rackDrag.letter = null;
            rackDrag.active = false;
            rackDrag.insertIndex = -1;
            rackDrag.completed = false;
        }

        // ============== Placed Tile Drag Functions ==============
        function initPlacedTileDrag(tile, row, col, x, y) {
            const placement = placedThisTurn.find(p => p.row === row && p.col === col);
            if (!placement) return;
            
            placedDrag.tile = tile;
            placedDrag.fromRow = row;
            placedDrag.fromCol = col;
            placedDrag.letter = placement.letter;
            placedDrag.originalLetter = placement.originalLetter;
            placedDrag.isBlank = tile.dataset.isBlank === 'true';
            placedDrag.startX = x;
            placedDrag.startY = y;
            placedDrag.currentX = x;
            placedDrag.currentY = y;
            placedDrag.active = false;
        }

        function activatePlacedTileDrag() {
            if (placedDrag.active || !placedDrag.tile) return;
            placedDrag.active = true;
            
            const tile = placedDrag.tile;
            tile.classList.add('rack-ghost');
            
            // Create floating clone
            placedDrag.floatingClone = tile.cloneNode(true);
            placedDrag.floatingClone.classList.remove('rack-ghost', 'placed-this-turn');
            placedDrag.floatingClone.classList.add('rack-dragging');
            placedDrag.floatingClone.style.width = '40px';
            placedDrag.floatingClone.style.height = '40px';
            document.body.appendChild(placedDrag.floatingClone);
            
            log('INPUT', 'Placed tile drag activated', { row: placedDrag.fromRow, col: placedDrag.fromCol, letter: placedDrag.letter });
        }

        function updatePlacedTileDrag(x, y) {
            placedDrag.currentX = x;
            placedDrag.currentY = y;
            
            // Move floating clone - AT finger position (not above like rack tiles)
            const clone = placedDrag.floatingClone;
            if (clone) {
                clone.style.left = (x - 20) + 'px';
                clone.style.top = (y - 20) + 'px';  // Centered on finger!
            }
            
            // Clear previous highlight
            if (placedDrag.highlightedCell) {
                placedDrag.highlightedCell.classList.remove('drag-hover', 'drag-board-target');
                placedDrag.highlightedCell = null;
            }
            
            // Check if over board - use FINGER position (same as tile)
            const boardEl = document.getElementById('board');
            const boardRect = boardEl.getBoundingClientRect();
            
            if (x >= boardRect.left && x <= boardRect.right && 
                y >= boardRect.top && y <= boardRect.bottom) {
                
                const element = document.elementFromPoint(x, y);
                const cell = element?.closest('.cell');
                
                if (cell) {
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const isOccupied = board[row][col];
                    const placedHere = placedThisTurn.find(p => p.row === row && p.col === col);
                    const isSameCell = row === placedDrag.fromRow && col === placedDrag.fromCol;
                    
                    // Valid if empty, or has our placed tile, or is the original cell
                    if (!isOccupied || placedHere || isSameCell) {
                        // Board-to-board uses 15% bigger target
                        cell.classList.add('drag-hover', 'drag-board-target');
                        placedDrag.highlightedCell = cell;
                    }
                }
            }
        }

        function endPlacedTileDrag(x, y) {
            if (!placedDrag.active) {
                cancelPlacedTileDrag();
                return;
            }
            
            // Clean up visuals
            if (placedDrag.tile) placedDrag.tile.classList.remove('rack-ghost');
            if (placedDrag.floatingClone) {
                placedDrag.floatingClone.remove();
                placedDrag.floatingClone = null;
            }
            if (placedDrag.highlightedCell) {
                placedDrag.highlightedCell.classList.remove('drag-hover', 'drag-board-target');
                placedDrag.highlightedCell = null;
            }
            
            // Find target cell - use FINGER position (same as tile for placed tiles)
            const boardEl = document.getElementById('board');
            const boardRect = boardEl.getBoundingClientRect();
            
            if (x >= boardRect.left && x <= boardRect.right && 
                y >= boardRect.top && y <= boardRect.bottom) {
                
                const element = document.elementFromPoint(x, y);
                const cell = element?.closest('.cell');
                
                if (cell) {
                    const toRow = parseInt(cell.dataset.row);
                    const toCol = parseInt(cell.dataset.col);
                    const fromRow = placedDrag.fromRow;
                    const fromCol = placedDrag.fromCol;
                    
                    // Don't move to same cell
                    if (toRow === fromRow && toCol === fromCol) {
                        resetPlacedDrag();
                        return;
                    }
                    
                    const isOccupied = board[toRow][toCol];
                    const placedHere = placedThisTurn.find(p => p.row === toRow && p.col === toCol);
                    
                    if (!isOccupied || placedHere) {
                        // If target has a placed tile, swap them or return that one
                        if (placedHere) {
                            // Return the tile at target to rack first
                            board[toRow][toCol] = null;
                            getCurrentRack().push(placedHere.originalLetter);
                            placedThisTurn = placedThisTurn.filter(p => p !== placedHere);
                            const targetCell = document.querySelector(`.cell[data-row="${toRow}"][data-col="${toCol}"]`);
                            restoreCell(targetCell, toRow, toCol);
                        }
                        
                        // Remove from old position
                        board[fromRow][fromCol] = null;
                        const oldPlacement = placedThisTurn.find(p => p.row === fromRow && p.col === fromCol);
                        placedThisTurn = placedThisTurn.filter(p => p !== oldPlacement);
                        const fromCell = document.querySelector(`.cell[data-row="${fromRow}"][data-col="${fromCol}"]`);
                        restoreCell(fromCell, fromRow, fromCol);
                        
                        // Place at new position (add letter back to rack temporarily for placeTile)
                        getCurrentRack().push(placedDrag.originalLetter);
                        const toCell = document.querySelector(`.cell[data-row="${toRow}"][data-col="${toCol}"]`);
                        placeTile(placedDrag.originalLetter, toRow, toCol, toCell, placedDrag.isBlank);
                        
                        log('INPUT', 'Moved placed tile', { from: {row: fromRow, col: fromCol}, to: {row: toRow, col: toCol}, letter: placedDrag.letter });
                        
                        animateTileDrop(toCell);
                    }
                }
            }
            
            resetPlacedDrag();
        }

        function cancelPlacedTileDrag() {
            if (placedDrag.tile) placedDrag.tile.classList.remove('rack-ghost');
            if (placedDrag.floatingClone) {
                placedDrag.floatingClone.remove();
                placedDrag.floatingClone = null;
            }
            if (placedDrag.highlightedCell) {
                placedDrag.highlightedCell.classList.remove('drag-hover', 'drag-board-target');
                placedDrag.highlightedCell = null;
            }
            resetPlacedDrag();
        }

        function resetPlacedDrag() {
            placedDrag.active = false;
            placedDrag.tile = null;
            placedDrag.fromRow = -1;
            placedDrag.fromCol = -1;
            placedDrag.letter = null;
            placedDrag.originalLetter = null;
            placedDrag.isBlank = false;
        }

        function createTileElement(letter, inRack = false) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.dataset.letter = letter;
            tile.draggable = false; // We'll handle our own dragging
            tile.innerHTML = `<span class="letter">${letter === '?' ? '' : letter}</span><span class="points">${LETTER_VALUES[letter]}</span>`;
            
            if (inRack) {
                // Get tile index dynamically
                const getTileIndex = () => {
                    const rack = document.getElementById('rack');
                    return Array.from(rack.children).indexOf(tile);
                };

                // Desktop: mousedown/mousemove/mouseup
                tile.addEventListener('mousedown', (e) => { 
                    e.stopPropagation();
                    const idx = getTileIndex();
                    log('INPUT', 'Tile mousedown', { letter: tile.dataset.letter, index: idx });
                    
                    // Init potential drag
                    initRackDrag(tile, e.clientX, e.clientY, idx);
                    
                    // Select tile immediately
                    if (selectedTile === tile) {
                        tile.classList.remove('selected');
                        selectedTile = null;
                        selectedLetter = null;
                    } else {
                        if (selectedTile) selectedTile.classList.remove('selected');
                        selectedTile = tile;
                        selectedLetter = tile.dataset.letter;
                        tile.classList.add('selected');
                    }
                });
                
                // Mobile: touchstart/touchmove/touchend
                tile.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent scroll immediately when touching tile
                    e.stopPropagation();
                    const touch = e.touches[0];
                    const idx = getTileIndex();
                    log('INPUT', 'Tile touch', { letter: tile.dataset.letter, index: idx });
                    
                    // Init potential drag
                    initRackDrag(tile, touch.clientX, touch.clientY, idx);
                    
                    // Select tile immediately
                    if (selectedTile === tile) {
                        tile.classList.remove('selected');
                        selectedTile = null;
                        selectedLetter = null;
                    } else {
                        if (selectedTile) selectedTile.classList.remove('selected');
                        selectedTile = tile;
                        selectedLetter = tile.dataset.letter;
                        tile.classList.add('selected');
                    }
                }, { passive: false }); // NOT passive so preventDefault works
                
                tile.addEventListener('touchmove', (e) => {
                    if (rackDrag.tile === tile) {
                        e.preventDefault(); // ALWAYS prevent scroll during drag
                        e.stopPropagation();
                        const touch = e.touches[0];
                        updateRackDrag(touch.clientX, touch.clientY);
                    }
                }, { passive: false });
                
                tile.addEventListener('touchend', (e) => {
                    if (rackDrag.tile === tile) {
                        if (rackDrag.active) {
                            e.preventDefault();
                            endRackDrag();
                        } else {
                            // It was just a tap, not a drag - selection already happened
                            rackDrag.tile = null;
                        }
                    }
                }, { passive: false });
            }
            return tile;
        }
        
        // Document-level mouse handlers for desktop drag
        document.addEventListener('mousemove', (e) => {
            if (rackDrag.tile) {
                updateRackDrag(e.clientX, e.clientY);
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (rackDrag.tile) {
                if (rackDrag.active) {
                    endRackDrag();
                } else {
                    // It was just a click, not a drag - selection already happened
                    rackDrag.tile = null;
                }
            }
        });

        function initBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    const type = getCellType(r, c);
                    cell.className = 'cell ' + type;
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    if (type === 'TW') cell.innerHTML = '<span class="premium-text">TRIPLE<br>WORD</span>';
                    else if (type === 'DW' && !(r === 7 && c === 7)) cell.innerHTML = '<span class="premium-text">DOUBLE<br>WORD</span>';
                    else if (type === 'TL') cell.innerHTML = '<span class="premium-text">TRIPLE<br>LETTER</span>';
                    else if (type === 'DL') cell.innerHTML = '<span class="premium-text">DOUBLE<br>LETTER</span>';
                    else if (type === 'center') cell.innerHTML = '<span class="star"></span>';
                    
                    // Mousedown handler for desktop - instant response
                    cell.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        log('INPUT', 'Cell mousedown', { row: r, col: c, hasSelectedTile: !!selectedTile, selectedLetter });
                        handleCellClick(r, c, cell, e);
                    });
                    
                    // Touch support for mobile - touchstart for immediate response
                    cell.addEventListener('touchstart', (e) => {
                        // Only handle if touching the cell itself, not a tile on it
                        if (e.target === cell || e.target.classList.contains('premium-text') || e.target.classList.contains('star')) {
                            // Only prevent scroll if we have a tile selected to place
                            if (selectedTile) {
                                e.preventDefault(); // Prevent scroll only when placing
                            }
                            log('INPUT', 'Cell touch', { row: r, col: c, hasSelectedTile: !!selectedTile });
                            handleCellClick(r, c, cell, e);
                        }
                    }, { passive: false }); // NOT passive so preventDefault can work when needed
                    
                    cell.addEventListener('dragover', e => { 
                        e.preventDefault(); 
                        const r = parseInt(cell.dataset.row);
                        const c = parseInt(cell.dataset.col);
                        // Allow drop on empty cells or cells with placed-this-turn tiles
                        if (!board[r][c] || placedThisTurn.some(p => p.row === r && p.col === c)) {
                            cell.classList.add('selected'); 
                        }
                    });
                    cell.addEventListener('dragleave', () => cell.classList.remove('selected'));
                    cell.addEventListener('drop', e => { 
                        e.preventDefault(); 
                        cell.classList.remove('selected'); 
                        const r = parseInt(cell.dataset.row);
                        const c = parseInt(cell.dataset.col);
                        
                        if (draggedPlacedTile) {
                            // Relocating a placed tile
                            relocatePlacedTile(r, c);
                        } else if (draggedTile) {
                            // Placing from rack
                            if (!board[r][c] || placedThisTurn.some(p => p.row === r && p.col === c)) {
                                placeTile(draggedTile.dataset.letter, r, c, cell);
                            }
                        }
                    });
                    boardEl.appendChild(cell);
                }
            }
            
            // Render existing tiles on board (for multiplayer sync)
            renderBoardTiles();
        }
        
        function renderBoardTiles() {
            // Render tiles that exist in the board array onto the DOM
            const boardEl = document.getElementById('board');
            const cells = boardEl.querySelectorAll('.cell');
            
            log('RENDER', 'renderBoardTiles starting', { cellCount: cells.length });
            
            // First count tiles in board array
            let tilesInArray = 0;
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (board[r][c]) tilesInArray++;
                }
            }
            log('RENDER', 'Tiles in board array', { tilesInArray });
            
            let tilesRendered = 0;
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    const cellIdx = r * 15 + c;
                    const cell = cells[cellIdx];
                    
                    if (board[r][c] && cell) {
                        // Remove any existing tile first
                        const existingTile = cell.querySelector('.tile');
                        if (existingTile) {
                            existingTile.remove();
                        }
                        
                        const tileData = board[r][c];
                        const letter = typeof tileData === 'string' ? tileData : (tileData.letter || '?');
                        const isBlank = tileData.isBlank || false;
                        
                        const tile = document.createElement('div');
                        tile.className = 'tile permanent';
                        tile.innerHTML = `<span class="letter">${letter}</span><span class="points">${isBlank ? 0 : LETTER_VALUES[letter] || 0}</span>`;
                        if (isBlank) tile.classList.add('blank-tile');
                        cell.appendChild(tile);
                        tilesRendered++;
                        
                        // Debug first few tiles
                        if (tilesRendered <= 3) {
                            log('RENDER', 'Tile added', { r, c, letter, cellIdx });
                        }
                    }
                }
            }
            log('RENDER', 'Board tiles rendered', { tilesRendered, tilesInArray });
        }

        function renderRack() {
            const rack = getCurrentRack();
            
            // ABSOLUTE LIMIT: Enforce max 7 tiles in rack
            if (rack.length > 7) {
                log('ERROR', 'Rack has >7 tiles in renderRack! Truncating.', { count: rack.length });
                rack.length = 7;
            }
            
            const rackEl = document.getElementById('rack');
            rackEl.innerHTML = '';
            rack.forEach(l => rackEl.appendChild(createTileElement(l, true)));
            
            // Clear any lingering magnified cells
            document.querySelectorAll('.cell.drag-magnify, .cell.drag-hover, .cell.drag-board-target').forEach(c => {
                c.classList.remove('drag-hover', 'drag-magnify', 'drag-board-target');
            });
            
            // Log rack state for debugging
            log('RACK', 'Rendered rack', { player: currentPlayer, count: rack.length, tiles: [...rack] });
            
            // INSTANT validation after every render (if turn has started)
            if (turnStartTiles.length > 0 && !isValidatingTiles) {
                isValidatingTiles = true;
                const valid = validateAndRecoverTiles();
                isValidatingTiles = false;
            }
            
            // Click on rack area to deselect
            rackEl.onclick = (e) => {
                if (e.target === rackEl && selectedTile) {
                    deselectTile();
                }
            };
        }

        function deselectTile() {
            if (selectedTile) selectedTile.classList.remove('selected');
            selectedTile = null;
            selectedLetter = null;
            hideFloatingTile();
        }

        function showFloatingTile(letter) {
            floatingTile = document.getElementById('floating-tile');
            floatingTile.querySelector('.letter').textContent = letter === '?' ? '?' : letter;
            floatingTile.querySelector('.points').textContent = LETTER_VALUES[letter];
            floatingTile.style.display = 'flex';
        }

        function hideFloatingTile() {
            const ft = document.getElementById('floating-tile');
            ft.style.display = 'none';
            floatingTile = null;
        }

        function handleTileClick(tile) {
            log('INPUT', 'handleTileClick called', { letter: tile.dataset.letter, wasSelected: selectedTile === tile });
            
            if (selectedTile === tile) {
                // Clicking same tile deselects
                log('INPUT', 'Deselecting tile');
                deselectTile();
            } else {
                // Select new tile
                if (selectedTile) selectedTile.classList.remove('selected');
                selectedTile = tile;
                selectedLetter = tile.dataset.letter;
                tile.classList.add('selected');
                log('INPUT', 'Tile selected', { letter: selectedLetter });
            }
        }

        // Click on placed tile to return to rack
        function handlePlacedTileClick(row, col, e) {
            e.stopPropagation();
            returnPlacedTile(row, col);
        }
        
        // Create double-click handler for placed tiles (desktop)
        function createPlacedTileClickHandler(tile, row, col) {
            // Desktop: use native dblclick event (more reliable with draggable elements)
            tile.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                e.preventDefault();
                returnPlacedTile(row, col);
            });
        }
        
        function returnPlacedTile(row, col) {
            const placement = placedThisTurn.find(p => p.row === row && p.col === col);
            if (placement) {
                // Return to rack
                board[row][col] = null;
                getCurrentRack().push(placement.originalLetter);
                placedThisTurn = placedThisTurn.filter(p => p !== placement);
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                restoreCell(cell, row, col);
                
                // Clear any magnified cells
                document.querySelectorAll('.cell.drag-magnify, .cell.drag-board-target').forEach(c => {
                    c.classList.remove('drag-hover', 'drag-magnify', 'drag-board-target');
                });
                
                renderRack();
                updateWordPreview();
            }
        }

        // Track mouse for floating tile
        document.addEventListener('mousemove', (e) => {
            if (floatingTile) {
                floatingTile.style.left = e.clientX + 'px';
                floatingTile.style.top = e.clientY + 'px';
            }
        });

        function handleCellClick(row, col, cell, e) {
            log('INPUT', 'handleCellClick called', { row, col, hasSelectedTile: !!selectedTile, selectedLetter });
            
            // If cell has a tile placed this turn, handle it
            const placement = placedThisTurn.find(p => p.row === row && p.col === col);
            if (placement) {
                // On mobile: single tap does nothing (double-tap handled by touch events)
                // On desktop: single click does nothing (double-click handled by dblclick event)
                // Just ignore - the tile's own event handlers will handle double-click/tap
                log('INPUT', 'Placed tile clicked - ignoring (use double-click/tap to return)');
                return;
            }
            
            // If cell has permanent tile, ignore
            if (board[row][col]) {
                log('INPUT', 'Cell has permanent tile, ignoring');
                return;
            }
            
            // If tile is selected, place it
            if (selectedTile) {
                log('INPUT', 'Placing selected tile', { letter: selectedLetter, row, col });
                placeTile(selectedTile.dataset.letter, row, col, cell);
                selectedTile.classList.remove('selected');
                selectedTile = null;
                selectedLetter = null;
                hideFloatingTile();
            } else {
                log('INPUT', 'No tile selected, nothing to place');
            }
        }

        function placeTile(letter, row, col, cell, isBlank = false) {
            let actual = letter;
            let originalLetter = letter;
            
            if (letter === '?') {
                actual = prompt('Blank letter (A-Z):')?.toUpperCase();
                if (!actual || !/^[A-Z]$/.test(actual)) return false;
                originalLetter = '?';
                isBlank = true;
            }
            
            const rack = getCurrentRack(), idx = rack.indexOf(isBlank ? '?' : letter);
            if (idx === -1 && !isBlank) return false;
            if (idx !== -1) rack.splice(idx, 1);

            const prev = placedThisTurn.find(p => p.row === row && p.col === col);
            if (prev) { rack.push(prev.originalLetter); placedThisTurn = placedThisTurn.filter(p => p !== prev); }

            const tile = createTileElement(actual);
            tile.classList.add('placed-this-turn');
            tile.draggable = !isMobile;
            tile.dataset.placedRow = row;
            tile.dataset.placedCol = col;
            tile.dataset.originalLetter = isBlank ? '?' : actual;
            if (isBlank) tile.dataset.isBlank = 'true';
            
            // Desktop: double-click to return to rack
            createPlacedTileClickHandler(tile, row, col);
            
            // Touch support for mobile - DOUBLE-tap to return, drag to move
            let placedTouchStart = null;
            let placedTouchMoved = false;
            let lastTapTime = 0;
            
            tile.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scroll when touching placed tile
                e.stopPropagation();
                const touch = e.touches[0];
                placedTouchStart = { x: touch.clientX, y: touch.clientY, row, col, tile };
                placedTouchMoved = false;
                
                // Initialize drag state for placed tile
                initPlacedTileDrag(tile, row, col, touch.clientX, touch.clientY);
            }, { passive: false });
            
            tile.addEventListener('touchmove', (e) => {
                if (!placedTouchStart) return;
                e.preventDefault(); // ALWAYS prevent scroll when moving placed tile
                e.stopPropagation();
                const touch = e.touches[0];
                const dx = touch.clientX - placedTouchStart.x;
                const dy = touch.clientY - placedTouchStart.y;
                
                if (Math.abs(dx) > 10 || Math.abs(dy) > 10) {
                    placedTouchMoved = true;
                    activatePlacedTileDrag();
                }
                
                if (placedDrag.active) {
                    updatePlacedTileDrag(touch.clientX, touch.clientY);
                }
            }, { passive: false });
            
            tile.addEventListener('touchend', (e) => {
                if (placedTouchMoved && placedDrag.active) {
                    e.preventDefault();
                    e.stopPropagation();
                    // Was a drag - move tile to new position
                    endPlacedTileDrag(e.changedTouches[0]?.clientX || placedDrag.currentX, 
                                      e.changedTouches[0]?.clientY || placedDrag.currentY);
                    lastTapTime = 0; // Reset double-tap timer after drag
                } else {
                    // Was a tap - check for double-tap
                    cancelPlacedTileDrag();
                    const now = Date.now();
                    if (now - lastTapTime < 400) {
                        // Double-tap! Return to rack
                        handlePlacedTileClick(row, col, e);
                        lastTapTime = 0;
                    } else {
                        // Single tap - just remember time, don't do anything yet
                        lastTapTime = now;
                    }
                }
                
                placedTouchStart = null;
                placedTouchMoved = false;
            });
            
            // Drag placed tile to relocate (desktop only)
            if (!isMobile) {
                tile.addEventListener('dragstart', handlePlacedDragStart);
                tile.addEventListener('dragend', handlePlacedDragEnd);
            }
            
            cell.innerHTML = '';
            cell.appendChild(tile);

            board[row][col] = { letter: actual, isBlank: isBlank };
            placedThisTurn.push({ row, col, letter: actual, originalLetter: isBlank ? '?' : actual, element: tile });

            renderRack();
            updateWordPreview();
            return true;
        }
        
        let draggedPlacedTile = null;
        let draggedFromRow = null;
        let draggedFromCol = null;
        
        function handlePlacedDragStart(e) {
            e.stopPropagation();
            draggedPlacedTile = e.target.closest('.tile');
            draggedFromRow = parseInt(draggedPlacedTile.dataset.placedRow);
            draggedFromCol = parseInt(draggedPlacedTile.dataset.placedCol);
            draggedPlacedTile.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handlePlacedDragEnd(e) {
            if (draggedPlacedTile) {
                draggedPlacedTile.classList.remove('dragging');
            }
            draggedPlacedTile = null;
            draggedFromRow = null;
            draggedFromCol = null;
            document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
        }
        
        function relocatePlacedTile(toRow, toCol) {
            if (draggedFromRow === null || draggedFromCol === null) return;
            if (toRow === draggedFromRow && toCol === draggedFromCol) return;
            
            // Get the placement info
            const placement = placedThisTurn.find(p => p.row === draggedFromRow && p.col === draggedFromCol);
            if (!placement) return;
            
            // Check if target is empty or has a placed-this-turn tile
            if (board[toRow][toCol] && !placedThisTurn.some(p => p.row === toRow && p.col === toCol)) {
                return; // Can't drop on permanent tile
            }
            
            // Remove from old position
            board[draggedFromRow][draggedFromCol] = null;
            const oldCell = document.querySelector(`.cell[data-row="${draggedFromRow}"][data-col="${draggedFromCol}"]`);
            restoreCell(oldCell, draggedFromRow, draggedFromCol);
            
            // If target has a placed tile, swap them
            const targetPlacement = placedThisTurn.find(p => p.row === toRow && p.col === toCol);
            if (targetPlacement) {
                // Move target tile to old position
                board[draggedFromRow][draggedFromCol] = { letter: targetPlacement.letter, isBlank: targetPlacement.originalLetter === '?' };
                targetPlacement.row = draggedFromRow;
                targetPlacement.col = draggedFromCol;
                
                const swapTile = createTileElement(targetPlacement.letter);
                swapTile.classList.add('placed-this-turn');
                swapTile.draggable = true;
                swapTile.dataset.placedRow = draggedFromRow;
                swapTile.dataset.placedCol = draggedFromCol;
                swapTile.dataset.originalLetter = targetPlacement.originalLetter;
                if (targetPlacement.originalLetter === '?') swapTile.dataset.isBlank = 'true';
                createPlacedTileClickHandler(swapTile, draggedFromRow, draggedFromCol);
                swapTile.addEventListener('dragstart', handlePlacedDragStart);
                swapTile.addEventListener('dragend', handlePlacedDragEnd);
                oldCell.innerHTML = '';
                oldCell.appendChild(swapTile);
                targetPlacement.element = swapTile;
            }
            
            // Place at new position
            const newCell = document.querySelector(`.cell[data-row="${toRow}"][data-col="${toCol}"]`);
            const newTile = createTileElement(placement.letter);
            newTile.classList.add('placed-this-turn');
            newTile.draggable = true;
            newTile.dataset.placedRow = toRow;
            newTile.dataset.placedCol = toCol;
            newTile.dataset.originalLetter = placement.originalLetter;
            if (placement.originalLetter === '?') newTile.dataset.isBlank = 'true';
            createPlacedTileClickHandler(newTile, toRow, toCol);
            newTile.addEventListener('dragstart', handlePlacedDragStart);
            newTile.addEventListener('dragend', handlePlacedDragEnd);
            
            newCell.innerHTML = '';
            newCell.appendChild(newTile);
            
            board[toRow][toCol] = { letter: placement.letter, isBlank: placement.originalLetter === '?' };
            placement.row = toRow;
            placement.col = toCol;
            placement.element = newTile;
            
            updateWordPreview();
        }

        function startTypingMode(row, col, cell) {
            typingCell = { row, col, element: cell };
            typingDirection = 'H'; // Default horizontal
            cell.classList.add('typing-start');
            showDirectionArrow(cell, 'H');
            const hint = document.getElementById('keyboard-hint');
            if (hint) hint.textContent = 'Type letters, /// change direction, ESC cancel';
            document.getElementById('typing-input').value = '';
            document.getElementById('typing-input').focus({ preventScroll: true });
        }

        function toggleTypingDirection(cell) {
            typingDirection = typingDirection === 'H' ? 'V' : 'H';
            showDirectionArrow(cell, typingDirection);
        }

        function showDirectionArrow(cell, direction) {
            // Remove existing arrows
            document.querySelectorAll('.direction-arrow').forEach(a => a.remove());
            
            const arrow = document.createElement('span');
            arrow.className = 'direction-arrow';
            arrow.textContent = direction === 'H' ? '' : '';
            cell.appendChild(arrow);
        }

        function clearTypingMode() {
            if (typingCell && typingCell.element) {
                typingCell.element.classList.remove('typing-start');
            }
            document.querySelectorAll('.direction-arrow').forEach(a => a.remove());
            typingCell = typingDirection = null;
            const hint = document.getElementById('keyboard-hint');
            if (hint) hint.textContent = 'Click tile  click cell';
        }

        document.getElementById('typing-input').addEventListener('keydown', e => {
            if (!typingCell) return;
            if (e.key === 'Escape') { clearTypingMode(); return; }
            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                typingDirection = 'H';
                showDirectionArrow(typingCell.element, 'H');
                e.preventDefault();
                return;
            }
            if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                typingDirection = 'V';
                showDirectionArrow(typingCell.element, 'V');
                e.preventDefault();
                return;
            }
            if (e.key === 'Enter') { 
                clearTypingMode(); 
                // Trigger Play if tiles are placed
                if (placedThisTurn.length > 0) {
                    document.getElementById('btn-play').click();
                }
                e.preventDefault();
                return; 
            }
            if (e.key === 'Backspace' && placedThisTurn.length > 0) {
                const last = placedThisTurn.pop();
                board[last.row][last.col] = null;
                getCurrentRack().push(last.originalLetter);
                restoreCell(document.querySelector(`.cell[data-row="${last.row}"][data-col="${last.col}"]`), last.row, last.col);
                renderRack();
                updateWordPreview();
                e.preventDefault();
                return;
            }
            if (/^[A-Za-z]$/.test(e.key)) {
                let row = typingCell.row, col = typingCell.col;
                if (placedThisTurn.length > 0) {
                    const last = placedThisTurn[placedThisTurn.length - 1];
                    row = last.row + (typingDirection === 'V' ? 1 : 0);
                    col = last.col + (typingDirection === 'H' ? 1 : 0);
                }
                // Skip existing tiles
                while (row < 15 && col < 15 && board[row][col] && !placedThisTurn.some(p => p.row === row && p.col === col)) {
                    row += typingDirection === 'V' ? 1 : 0;
                    col += typingDirection === 'H' ? 1 : 0;
                }
                if (row >= 15 || col >= 15) return;
                const letter = e.key.toUpperCase(), rack = getCurrentRack();
                const useLetter = rack.includes(letter) ? letter : (rack.includes('?') ? '?' : null);
                if (!useLetter) { showMessage(`No "${letter}" in rack`, 'error'); return; }
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                if (useLetter === '?') {
                    rack.splice(rack.indexOf('?'), 1);
                    const tile = createTileElement(letter);
                    tile.classList.add('placed-this-turn');
                    tile.dataset.isBlank = 'true';
                    tile.dataset.placedRow = row;
                    tile.dataset.placedCol = col;
                    tile.dataset.originalLetter = '?';
                    tile.draggable = true;
                    createPlacedTileClickHandler(tile, row, col);
                    tile.addEventListener('dragstart', handlePlacedDragStart);
                    tile.addEventListener('dragend', handlePlacedDragEnd);
                    cell.innerHTML = '';
                    cell.appendChild(tile);
                    board[row][col] = { letter, isBlank: true };
                    placedThisTurn.push({ row, col, letter, originalLetter: '?', element: tile });
                    renderRack();
                    updateWordPreview();
                } else {
                    placeTile(letter, row, col, cell);
                }
                e.preventDefault();
            }
        });

        function handleDragStart(e) { 
            e.stopPropagation(); // Prevent click from firing
            draggedTile = e.target.closest('.tile'); 
            draggedTile.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', ''); // Required for Firefox
        }
        
        function handleDragEnd(e) { 
            if (draggedTile) draggedTile.classList.remove('dragging'); 
            draggedTile = null;
            document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
        }

        // Allow dropping back on rack to cancel
        document.getElementById('rack').addEventListener('dragover', e => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        });

        document.getElementById('rack').addEventListener('drop', e => {
            e.preventDefault();
            if (draggedPlacedTile) {
                // Return placed tile to rack
                const placement = placedThisTurn.find(p => p.row === draggedFromRow && p.col === draggedFromCol);
                if (placement) {
                    board[draggedFromRow][draggedFromCol] = null;
                    getCurrentRack().push(placement.originalLetter);
                    placedThisTurn = placedThisTurn.filter(p => p !== placement);
                    const cell = document.querySelector(`.cell[data-row="${draggedFromRow}"][data-col="${draggedFromCol}"]`);
                    restoreCell(cell, draggedFromRow, draggedFromCol);
                    renderRack();
                    updateWordPreview();
                }
                draggedPlacedTile = null;
                draggedFromRow = null;
                draggedFromCol = null;
            }
            // Dragging from rack back to rack = no-op, tile stays
            draggedTile = null;
        });

        function restoreCell(cell, row, col) {
            const type = getCellType(row, col);
            cell.innerHTML = type === 'TW' ? '<span class="premium-text">TRIPLE<br>WORD</span>' :
                type === 'DW' && !(row === 7 && col === 7) ? '<span class="premium-text">DOUBLE<br>WORD</span>' :
                type === 'TL' ? '<span class="premium-text">TRIPLE<br>LETTER</span>' :
                type === 'DL' ? '<span class="premium-text">DOUBLE<br>LETTER</span>' :
                type === 'center' ? '<span class="star"></span>' : '';
        }

        async function validateWord(word) {
            try { return (await (await fetch('/api/check?word=' + encodeURIComponent(word))).json()).valid; }
            catch { return true; }
        }

        function getFormedWords() {
            if (!placedThisTurn.length) return [];
            const words = [], rows = [...new Set(placedThisTurn.map(p => p.row))], cols = [...new Set(placedThisTurn.map(p => p.col))];
            const isH = rows.length === 1, isV = cols.length === 1;

            const getWord = (startR, startC, dr, dc) => {
                let word = '', positions = [], r = startR, c = startC;
                while (r >= 0 && c >= 0 && board[r][c]) { r -= dr; c -= dc; }
                r += dr; c += dc;
                while (r < 15 && c < 15 && board[r][c]) {
                    word += board[r][c].letter;
                    positions.push({ row: r, col: c, ...board[r][c], isNew: placedThisTurn.some(p => p.row === r && p.col === c) });
                    r += dr; c += dc;
                }
                return word.length > 1 ? { word, positions } : null;
            };

            if (isH || placedThisTurn.length === 1) {
                const w = getWord(placedThisTurn[0].row, Math.min(...placedThisTurn.map(p => p.col)), 0, 1);
                if (w) words.push(w);
            }
            if (isV || placedThisTurn.length === 1) {
                const w = getWord(Math.min(...placedThisTurn.map(p => p.row)), placedThisTurn[0].col, 1, 0);
                if (w && !words.some(x => x.word === w.word)) words.push(w);
            }
            placedThisTurn.forEach(({ row, col }) => {
                if (isH) { const w = getWord(row, col, 1, 0); if (w && !words.some(x => x.word === w.word && x.positions[0].col === w.positions[0].col)) words.push(w); }
                if (isV) { const w = getWord(row, col, 0, 1); if (w && !words.some(x => x.word === w.word && x.positions[0].row === w.positions[0].row)) words.push(w); }
            });
            return words;
        }

        function calculateScore(words) {
            let total = 0;
            words.forEach(({ positions }) => {
                let ws = 0, wm = 1;
                positions.forEach(p => {
                    let v = p.isBlank ? 0 : LETTER_VALUES[p.letter] || 0;
                    if (p.isNew) {
                        if (TL.some(x => x[0] === p.row && x[1] === p.col)) v *= 3;
                        else if (DL.some(x => x[0] === p.row && x[1] === p.col)) v *= 2;
                        if (TW.some(x => x[0] === p.row && x[1] === p.col)) wm *= 3;
                        else if (DW.some(x => x[0] === p.row && x[1] === p.col)) wm *= 2;
                    }
                    ws += v;
                });
                total += ws * wm;
            });
            if (placedThisTurn.length === 7) total += 50;
            return total;
        }

        async function updateWordPreview() {
            const preview = document.getElementById('word-preview'), words = getFormedWords();
            
            if (!words.length) {
                preview.innerHTML = '<span style="opacity:0.5;font-size:10px;">Place tiles</span>';
                document.getElementById('move-score').textContent = '0';
                // Play button stays enabled - validation happens on click
                return;
            }
            preview.innerHTML = '';
            let allValid = true;
            for (const { word } of words) {
                const chip = document.createElement('span');
                chip.className = 'word-chip';
                chip.textContent = word;
                const valid = await validateWord(word);
                chip.classList.add(valid ? 'valid' : 'invalid');
                if (!valid) allValid = false;
                preview.appendChild(chip);
            }
            document.getElementById('move-score').textContent = calculateScore(words);
            // Play button stays enabled - validation happens on click
        }

        function validatePlacement() {
            if (!placedThisTurn.length) return false;
            const rows = [...new Set(placedThisTurn.map(p => p.row))], cols = [...new Set(placedThisTurn.map(p => p.col))];
            if (rows.length > 1 && cols.length > 1) return false;
            if (isFirstMove) return placedThisTurn.some(p => p.row === 7 && p.col === 7);
            return placedThisTurn.some(({ row, col }) =>
                [[row-1,col],[row+1,col],[row,col-1],[row,col+1]].some(([r,c]) =>
                    r >= 0 && r < 15 && c >= 0 && c < 15 && board[r][c] && !placedThisTurn.some(p => p.row === r && p.col === c)));
        }

        function showMessage(text, type = 'info') {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = 'message ' + type;
            msg.style.display = 'block';
            setTimeout(() => msg.style.display = 'none', 3000);
        }

        async function playWord() {
            const words = getFormedWords();
            
            // Check if any tiles are placed
            if (placedThisTurn.length === 0) {
                showMessage('Place some tiles first!', 'error');
                return;
            }
            
            // Check placement is valid
            if (!validatePlacement()) {
                showMessage('Invalid tile placement!', 'error');
                return;
            }
            
            log('GAME', 'Attempting to play word', { words: words.map(w => w.word), player: currentPlayer });
            for (const { word } of words) if (!(await validateWord(word))) { 
                log('GAME', 'Invalid word rejected', { word });
                showMessage(`"${word}" invalid!`, 'error'); 
                return; 
            }
            const score = calculateScore(words);
            scores[currentPlayer - 1] += score;
            
            // Track played words for Define feature
            const playedWords = words.map(w => w.word);
            recentlyPlayedWords = playedWords;
            
            // Add to word history (keep last 10)
            wordHistory = [...playedWords, ...wordHistory].slice(0, 10);
            
            log('GAME', 'Word played successfully', { words: playedWords, score, totalScore: scores[currentPlayer - 1] });
            placedThisTurn.forEach(p => p.element?.classList.remove('placed-this-turn'));
            placedThisTurn = [];
            isFirstMove = false;
            
            // Draw tiles to fill rack to 7 (with safeguard)
            const currentRack = getCurrentRack();
            const tilesToDraw = Math.max(0, 7 - currentRack.length);
            const newTiles = drawTiles(tilesToDraw);
            setCurrentRack([...currentRack, ...newTiles].slice(0, 7)); // Safeguard: max 7
            
            showMessage(`+${score} points!`, 'success');
            switchPlayer();
        }

        function recallTiles() {
            placedThisTurn.forEach(({ row, col, originalLetter }) => {
                board[row][col] = null;
                getCurrentRack().push(originalLetter);
                restoreCell(document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`), row, col);
            });
            placedThisTurn = [];
            
            // Clear any magnified cells
            document.querySelectorAll('.cell.drag-magnify, .cell.drag-board-target').forEach(c => {
                c.classList.remove('drag-hover', 'drag-magnify', 'drag-board-target');
            });
            
            renderRack();
            updateWordPreview();
            clearTypingMode();
        }

        function switchPlayer() {
            // In multiplayer, don't use this - server manages turns
            if (multiplayerMode) {
                log('GAME', 'switchPlayer skipped in multiplayer mode');
                return;
            }
            
            stopTimer();
            log('GAME', 'Switching player', { from: currentPlayer, to: currentPlayer === 1 ? 2 : 1 });
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            saveTurnStartTiles(); // Track tiles for new turn!
            updateUI();
            if (gameMode === 'ai' && currentPlayer === 2) {
                setTimeout(doAiMove, 500);
            } else {
                startTimer();
            }
        }

        async function doAiMove() {
            document.getElementById('ai-thinking').style.display = 'flex';
            // Update AI status indicator
            const aiStatus = document.getElementById('ai-status');
            aiStatus.classList.add('thinking');
            aiStatus.querySelector('.ai-status-text').textContent = 'AI thinking...';
            
            const boardData = [];
            for (let r = 0; r < 15; r++) for (let c = 0; c < 15; c++) if (board[r][c]) boardData.push({ row: r, col: c, letter: board[r][c].letter, is_blank: board[r][c].isBlank });
            
            log('AI', 'Starting AI move', { rack: getCurrentRack(), boardTiles: boardData.length });
            
            try {
                const res = await fetch('/api/ai_move', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ board: boardData, rack: getCurrentRack(), difficulty: aiDifficulty }) });
                const data = await res.json();
                
                log('AI', 'AI response received', data);
                
                document.getElementById('ai-thinking').style.display = 'none';
                aiStatus.classList.remove('thinking');
                aiStatus.querySelector('.ai-status-text').textContent = 'Ready';
                
                if (data.success) {
                    // Validate the word client-side too
                    const wordValid = await validateWord(data.word);
                    log('AI', 'Client-side word validation', { word: data.word, valid: wordValid });
                    
                    if (!wordValid) {
                        log('AI', 'ERROR: AI returned invalid word!', { word: data.word });
                        showMessage(`AI tried invalid word: ${data.word}`, 'error');
                        switchPlayer();
                        return;
                    }
                    
                    data.tiles.forEach(tile => {
                        const cell = document.querySelector(`.cell[data-row="${tile.row}"][data-col="${tile.col}"]`);
                        cell.innerHTML = '';
                        cell.appendChild(createTileElement(tile.letter));
                        board[tile.row][tile.col] = { letter: tile.letter, isBlank: tile.is_blank };
                        const rack = getCurrentRack(), idx = tile.is_blank ? rack.indexOf('?') : rack.indexOf(tile.letter);
                        if (idx > -1) rack.splice(idx, 1);
                    });
                    scores[1] += data.score;
                    isFirstMove = false;
                    
                    // Track AI played word for Define feature
                    recentlyPlayedWords = [data.word];
                    wordHistory = [data.word, ...wordHistory].slice(0, 10);
                    
                    // Draw tiles to fill rack to 7 (with safeguard)
                    const aiRack = getCurrentRack();
                    const tilesToDraw = Math.max(0, 7 - aiRack.length);
                    const newTiles = drawTiles(tilesToDraw);
                    setCurrentRack([...aiRack, ...newTiles].slice(0, 7)); // Safeguard: max 7
                    
                    log('AI', 'AI move completed', { word: data.word, score: data.score, newRackSize: getCurrentRack().length });
                    
                    showMessage(`AI: "${data.word}" +${data.score}`, 'info');
                } else {
                    log('AI', 'AI passes');
                    showMessage('AI passes', 'info');
                }
                switchPlayer();
            } catch(e) { 
                log('AI', 'AI error', { error: e.message });
                document.getElementById('ai-thinking').style.display = 'none';
                aiStatus.classList.remove('thinking');
                aiStatus.querySelector('.ai-status-text').textContent = 'Ready';
                showMessage('AI error', 'error'); 
                switchPlayer(); 
            }
        }

        let hintPreviewTiles = []; // Track hint preview tiles

        async function getHint() {
            // Clear any existing hint preview
            clearHintPreview();
            
            showMessage('Finding best move...', 'info');
            const boardData = [];
            for (let r = 0; r < 15; r++) for (let c = 0; c < 15; c++) if (board[r][c]) boardData.push({ row: r, col: c, letter: board[r][c].letter });
            try {
                const res = await fetch('/api/hint', { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ board: boardData, rack: getCurrentRack(), difficulty: 'hard' })  // Always hard for hints
                });
                const data = await res.json();
                if (data.success) {
                    // Preview tiles on board
                    previewHintOnBoard(data);
                    
                    // Add hint word to history for Define feature
                    if (!wordHistory.includes(data.word)) {
                        wordHistory = [data.word, ...wordHistory].slice(0, 10);
                    }
                    
                    showMessage(`Best: "${data.word}" = ${data.score}pts (Play or Recall)`, 'success');
                } else {
                    showMessage('No moves found!', 'info');
                }
            } catch { showMessage('Hint error', 'error'); }
        }

        function previewHintOnBoard(hintData) {
            // Clear existing preview
            clearHintPreview();
            
            const rack = getCurrentRack();
            
            hintData.tiles.forEach(tile => {
                const cell = document.querySelector(`.cell[data-row="${tile.row}"][data-col="${tile.col}"]`);
                
                // Create preview tile
                const tileEl = createTileElement(tile.letter);
                tileEl.classList.add('placed-this-turn', 'hint-preview');
                tileEl.draggable = true;
                tileEl.dataset.placedRow = tile.row;
                tileEl.dataset.placedCol = tile.col;
                tileEl.dataset.originalLetter = tile.is_blank ? '?' : tile.letter;
                if (tile.is_blank) tileEl.dataset.isBlank = 'true';
                
                createPlacedTileClickHandler(tileEl, tile.row, tile.col);
                tileEl.addEventListener('dragstart', handlePlacedDragStart);
                tileEl.addEventListener('dragend', handlePlacedDragEnd);
                
                cell.innerHTML = '';
                cell.appendChild(tileEl);
                
                // Update game state
                board[tile.row][tile.col] = { letter: tile.letter, isBlank: tile.is_blank };
                
                // Remove from rack
                const rackIdx = tile.is_blank ? rack.indexOf('?') : rack.indexOf(tile.letter);
                if (rackIdx > -1) rack.splice(rackIdx, 1);
                
                // Track placement
                placedThisTurn.push({ 
                    row: tile.row, 
                    col: tile.col, 
                    letter: tile.letter, 
                    originalLetter: tile.is_blank ? '?' : tile.letter, 
                    element: tileEl 
                });
                
                hintPreviewTiles.push({ row: tile.row, col: tile.col });
            });
            
            renderRack();
            updateWordPreview();
        }

        function clearHintPreview() {
            // Remove hint preview styling (tiles stay as normal placed tiles)
            document.querySelectorAll('.tile.hint-preview').forEach(t => t.classList.remove('hint-preview'));
            hintPreviewTiles = [];
        }

        function updateUI() {
            document.getElementById('player1-score').classList.toggle('current', currentPlayer === 1);
            document.getElementById('player2-score').classList.toggle('current', currentPlayer === 2);
            document.getElementById('player1-score').querySelector('.score').textContent = scores[0];
            document.getElementById('player2-score').querySelector('.score').textContent = scores[1];
            document.getElementById('turn-indicator').textContent = currentPlayer === 1 ? 'Your turn' : (gameMode === 'ai' ? 'AI thinking...' : 'Player 2');
            document.getElementById('bag-count').textContent = bag.length;
            document.getElementById('rack-label').textContent = gameMode === 'ai' && currentPlayer === 2 ? 'AI' : 'Your Rack';
            if (gameMode === 'ai' && currentPlayer === 2) document.getElementById('rack').innerHTML = '';
            else renderRack();
            updateWordPreview();
        }

        // Global escape key to deselect
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                deselectTile();
            }
        });

        document.querySelectorAll('.mode-btn').forEach(btn => btn.addEventListener('click', () => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            gameMode = btn.dataset.mode;
            document.getElementById('difficulty').style.display = gameMode === 'ai' ? 'inline' : 'none';
            document.getElementById('player2-name').textContent = gameMode === 'ai' ? 'AI' : 'Player 2';
            initGame();
        }));

        document.getElementById('difficulty').addEventListener('change', e => aiDifficulty = e.target.value);
        document.getElementById('btn-play').addEventListener('click', playWord);
        document.getElementById('btn-recall').addEventListener('click', recallTiles);
        document.getElementById('btn-shuffle').addEventListener('click', () => { shuffleArray(getCurrentRack()); renderRack(); });
        document.getElementById('btn-hint').addEventListener('click', getHint);
        document.getElementById('btn-pass').addEventListener('click', pass);
        
        // New Game button with confirmation
        document.getElementById('btn-new-game').addEventListener('click', () => {
            if (confirm('Start a new game? Current progress will be lost.')) {
                initGame();
                showMessage('New game started!', 'success');
            }
        });
        
        // Mobile New Game button
        document.getElementById('btn-new-game-mobile').addEventListener('click', () => {
            if (confirm('Start a new game? Current progress will be lost.')) {
                initGame();
                showMessage('New game started!', 'success');
            }
        });
        
        // Mobile AI difficulty selector
        document.getElementById('difficulty-mobile').addEventListener('change', (e) => {
            aiDifficulty = e.target.value;
            // Sync with desktop selector
            document.getElementById('difficulty').value = e.target.value;
        });
        
        // Sync desktop difficulty to mobile
        document.getElementById('difficulty').addEventListener('change', (e) => {
            document.getElementById('difficulty-mobile').value = e.target.value;
        });

        function pass() {
            log('GAME', 'Player passed', { player: currentPlayer });
            recallTiles();
            showMessage('Passed', 'info');
            switchPlayer();
        }

        // ============== Theme Controls ==============
        let currentBaseColor = [169, 198, 229]; // RGB - Ocean Blue default
        let currentLightness = 75; // 3/4 to dark
        let timerSeconds = 0;
        let timerInterval = null;
        let currentTimer = 0;

        // Theme presets
        const THEME_PRESETS = {
            default: {
                name: 'Ocean Blue',
                boardColor: [169, 198, 229],
                lightness: 75,
                tw: '#e06070',
                dw: '#f0a8b8',
                tl: '#40a0b0',
                dl: '#90c8e0',
                bodyBg: 'linear-gradient(145deg, #2d2d2d 0%, #1a1a1a 100%)'
            },
            sage: {
                name: 'Classic Sage',
                boardColor: [142, 142, 80],
                lightness: 50,
                tw: '#c75050',
                dw: '#d4a0a8',
                tl: '#4090a0',
                dl: '#88b8c8',
                bodyBg: 'linear-gradient(145deg, #2d2d2d 0%, #1a1a1a 100%)'
            },
            dark: {
                name: 'Dark Mode',
                boardColor: [50, 50, 50],
                lightness: 70,
                tw: '#8b3a4a',
                dw: '#6b4a50',
                tl: '#3a6a7a',
                dl: '#4a6878',
                bodyBg: 'linear-gradient(145deg, #1a1a1a 0%, #0d0d0d 100%)'
            },
            forest: {
                name: 'Forest',
                boardColor: [80, 120, 80],
                lightness: 50,
                tw: '#a04040',
                dw: '#c8a090',
                tl: '#306868',
                dl: '#70a8a0',
                bodyBg: 'linear-gradient(145deg, #1a2a1a 0%, #0d1a0d 100%)'
            },
            warm: {
                name: 'Warm Wood',
                boardColor: [180, 140, 100],
                lightness: 50,
                tw: '#b04050',
                dw: '#d8a898',
                tl: '#508080',
                dl: '#98c0b8',
                bodyBg: 'linear-gradient(145deg, #2a2018 0%, #1a1008 100%)'
            }
        };

        // Tile style presets
        const TILE_STYLES = {
            wood: {
                name: 'Classic Wood',
                face1: '#e8cdb8',
                face2: '#dfc0a8',
                face3: '#d4b090',
                face4: '#c8a078',
                border: '#a07050',
                borderLight: '#c89878',
                text: '#2a2018'
            },
            ivory: {
                name: 'Ivory',
                face1: '#f8f4e8',
                face2: '#f0ece0',
                face3: '#e8e4d8',
                face4: '#e0dcd0',
                border: '#c0b8a0',
                borderLight: '#d8d0c0',
                text: '#3a3020'
            },
            dark: {
                name: 'Dark',
                face1: '#4a4035',
                face2: '#423830',
                face3: '#3a3028',
                face4: '#322820',
                border: '#2a2018',
                borderLight: '#5a4a38',
                text: '#f0e8d8'
            },
            blue: {
                name: 'Blue',
                face1: '#b8d0e8',
                face2: '#a8c0d8',
                face3: '#98b0c8',
                face4: '#88a0b8',
                border: '#6080a0',
                borderLight: '#a0c0e0',
                text: '#1a2a3a'
            }
        };

        let currentTileStyle = 'wood';

        function applyTileStyle(styleName) {
            const style = TILE_STYLES[styleName];
            if (!style) return;
            currentTileStyle = styleName;
            
            document.documentElement.style.setProperty('--tile-face-1', style.face1);
            document.documentElement.style.setProperty('--tile-face-2', style.face2);
            document.documentElement.style.setProperty('--tile-face-3', style.face3);
            document.documentElement.style.setProperty('--tile-face-4', style.face4);
            document.documentElement.style.setProperty('--tile-border', style.border);
            document.documentElement.style.setProperty('--tile-border-light', style.borderLight);
            document.documentElement.style.setProperty('--tile-text', style.text);
        }

        // Word definition and hints - via server
        async function getWordDefinition(word) {
            try {
                const response = await fetch('/api/define', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word: word })
                });
                const data = await response.json();
                return data.definition || 'Definition not found';
            } catch (e) {
                console.error('Definition error:', e);
                return 'Could not fetch definition';
            }
        }

        async function getFunnyHint(word, rack) {
            try {
                const response = await fetch('/api/funny_hint', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ word: word, rack: rack })
                });
                const data = await response.json();
                return data.hint || 'Hmm, I\'m stumped too!';
            } catch (e) {
                console.error('Hint error:', e);
                return 'My wit seems to have wandered off...';
            }
        }

        // Saved themes
        function saveCustomTheme(name) {
            const themes = JSON.parse(localStorage.getItem('scrabbleThemes') || '{}');
            themes[name] = {
                boardColor: currentBaseColor,
                lightness: currentLightness,
                tw: document.getElementById('tw-color').value,
                dw: document.getElementById('dw-color').value,
                tl: document.getElementById('tl-color').value,
                dl: document.getElementById('dl-color').value
            };
            localStorage.setItem('scrabbleThemes', JSON.stringify(themes));
            updateSavedThemesList();
            showMessage(`Theme "${name}" saved!`, 'success');
        }

        function loadCustomTheme(name) {
            const themes = JSON.parse(localStorage.getItem('scrabbleThemes') || '{}');
            if (themes[name]) {
                const t = themes[name];
                currentBaseColor = t.boardColor;
                currentLightness = t.lightness;
                document.getElementById('tw-color').value = t.tw;
                document.getElementById('dw-color').value = t.dw;
                document.getElementById('tl-color').value = t.tl;
                document.getElementById('dl-color').value = t.dl;
                document.getElementById('lightness-slider').value = t.lightness;
                const hex = '#' + t.boardColor.map(c => c.toString(16).padStart(2, '0')).join('');
                document.getElementById('board-color-picker').value = hex;
                document.getElementById('color-picker-btn').style.background = hex;
                applyPremiumColors();
                applyBoardTheme();
                showMessage(`Theme "${name}" loaded!`, 'success');
            }
        }

        function deleteCustomTheme(name) {
            const themes = JSON.parse(localStorage.getItem('scrabbleThemes') || '{}');
            delete themes[name];
            localStorage.setItem('scrabbleThemes', JSON.stringify(themes));
            updateSavedThemesList();
        }

        function updateSavedThemesList() {
            const container = document.getElementById('saved-themes-list');
            if (!container) return;
            const themes = JSON.parse(localStorage.getItem('scrabbleThemes') || '{}');
            const names = Object.keys(themes);
            if (names.length === 0) {
                container.innerHTML = '<span style="opacity:0.5;font-size:9px;">No saved themes</span>';
            } else {
                container.innerHTML = names.map(name => 
                    `<div class="saved-theme-item">
                        <span class="saved-theme-name" onclick="loadCustomTheme('${name}')">${name}</span>
                        <span class="saved-theme-delete" onclick="deleteCustomTheme('${name}')"></span>
                    </div>`
                ).join('');
            }
        }

        // Settings toggle
        document.getElementById('settings-toggle').addEventListener('click', () => {
            const content = document.getElementById('settings-content');
            const arrow = document.getElementById('settings-arrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.classList.add('open');
            } else {
                content.style.display = 'none';
                arrow.classList.remove('open');
            }
        });

        // Theme preset buttons
        document.querySelectorAll('.theme-preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.theme-preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const preset = THEME_PRESETS[btn.dataset.theme];
                if (preset) {
                    applyThemePreset(preset);
                }
            });
        });

        function applyThemePreset(preset) {
            // Apply board color
            currentBaseColor = preset.boardColor;
            currentLightness = preset.lightness;
            
            // Update UI controls
            const hex = '#' + currentBaseColor.map(c => c.toString(16).padStart(2, '0')).join('');
            document.getElementById('board-color-picker').value = hex;
            document.getElementById('color-picker-btn').style.background = hex;
            document.getElementById('lightness-slider').value = currentLightness;
            
            // Deselect color presets, select matching one if exists
            document.querySelectorAll('.color-preset').forEach(p => {
                p.classList.remove('active');
                if (p.dataset.color === currentBaseColor.join(',')) {
                    p.classList.add('active');
                }
            });
            
            // Apply premium colors
            document.getElementById('tw-color').value = preset.tw;
            document.getElementById('dw-color').value = preset.dw;
            document.getElementById('tl-color').value = preset.tl;
            document.getElementById('dl-color').value = preset.dl;
            
            applyPremiumColors();
            applyBoardTheme();
            
            // Apply body background
            if (preset.bodyBg) {
                document.body.style.background = preset.bodyBg;
            }
        }

        // Track recently played words for Define feature
        // (recentlyPlayedWords is declared at top)

        // Define button - prompt for word or show picker
        document.getElementById('btn-define').addEventListener('click', async () => {
            // Get unique words from history
            const uniqueWords = [...new Set(wordHistory)];
            
            if (uniqueWords.length === 0) {
                // No history - prompt to type
                const word = prompt('Enter a word to define:');
                if (word && word.trim()) {
                    await showDefinition(word.trim().toUpperCase());
                }
                return;
            }
            
            // Show word picker in AI response box
            const box = document.getElementById('ai-response-box');
            const text = document.getElementById('ai-response-text');
            
            // Create clickable word list
            let html = '<div style="margin-bottom:8px;font-weight:600;">Click a word to define:</div>';
            uniqueWords.forEach(word => {
                html += `<button onclick="defineWord('${word}')" style="
                    background: rgba(100,80,140,0.4);
                    border: 1px solid rgba(140,120,180,0.5);
                    color: #e8e0f0;
                    padding: 4px 10px;
                    margin: 2px;
                    border-radius: 4px;
                    cursor: pointer;
                    font-size: 11px;
                ">${word}</button>`;
            });
            html += `<br><button onclick="promptCustomWord()" style="
                background: rgba(60,80,60,0.4);
                border: 1px solid rgba(100,140,100,0.5);
                color: #a0d0a0;
                padding: 4px 10px;
                margin-top: 6px;
                border-radius: 4px;
                cursor: pointer;
                font-size: 10px;
            "> Type custom word</button>`;
            
            text.innerHTML = html;
        });

        // Global function for word buttons
        window.defineWord = async function(word) {
            await showDefinition(word);
        };
        
        window.promptCustomWord = async function() {
            const word = prompt('Enter a word to define:');
            if (word && word.trim()) {
                await showDefinition(word.trim().toUpperCase());
            }
        };

        async function showDefinition(word) {
            const box = document.getElementById('ai-response-box');
            const text = document.getElementById('ai-response-text');
            text.textContent = ` Looking up "${word}"...`;
            
            const definition = await getWordDefinition(word);
            text.textContent = ` ${word}: ${definition}`;
        }

        // Funny Hint/Clue button - gets Scrabble AI best word, then Claude hint
        document.getElementById('btn-funny-hint').addEventListener('click', async () => {
            const rack = getCurrentRack();
            if (rack.length === 0) {
                showMessage('No tiles in rack!', 'error');
                return;
            }
            
            const text = document.getElementById('ai-response-text');
            text.textContent = ' Getting witty clue...';
            
            // First get the best word from Scrabble AI
            const boardData = [];
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (board[r][c]) {
                        boardData.push({ row: r, col: c, letter: board[r][c].letter });
                    }
                }
            }
            
            try {
                const res = await fetch('/api/hint', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ board: boardData, rack: rack, difficulty: 'hard' })
                });
                const data = await res.json();
                
                if (data.success) {
                    // Now get funny hint from Claude AI
                    const funnyHint = await getFunnyHint(data.word, rack);
                    text.textContent = ` ${funnyHint}\n\n(${data.score} pts possible)`;
                } else {
                    text.textContent = ' No moves found!';
                }
            } catch (e) {
                console.error('Clue error:', e);
                text.textContent = ' Could not get clue';
            }
        });

        // Tile style buttons
        document.querySelectorAll('.tile-style-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tile-style-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                applyTileStyle(btn.dataset.style);
                renderRack(); // Re-render rack with new style
            });
        });

        // Timer functions
        function applyTimerSetting() {
            timerSeconds = parseInt(document.getElementById('timer-setting').value) || 0;
            log('TIMER', 'Timer setting changed', { timerSeconds });
            showMessage(timerSeconds > 0 ? `Timer set to ${timerSeconds}s` : 'Timer disabled', 'info');
        }

        let graceMode = false;

        function startTimer() {
            if (timerSeconds <= 0) return;
            currentTimer = timerSeconds;
            graceMode = false;
            log('TIMER', 'Timer started', { currentTimer, player: currentPlayer });
            updateTimerDisplay();
            
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                currentTimer--;
                updateTimerDisplay();
                if (currentTimer <= 0) {
                    if (!graceMode) {
                        // Start 5 second grace period
                        graceMode = true;
                        currentTimer = 5;
                        log('TIMER', 'Grace period started', { player: currentPlayer });
                        showMessage(' 5 second grace period!', 'error');
                    } else {
                        // Grace period over - force pass
                        clearInterval(timerInterval);
                        timerInterval = null;
                        log('TIMER', 'Time expired - forcing pass', { player: currentPlayer });
                        showMessage('Time\'s up! Turn passed.', 'error');
                        recallTiles();
                        pass();
                    }
                }
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                log('TIMER', 'Timer stopped');
            }
            graceMode = false;
            const timerEl = document.getElementById('timer-display');
            if (timerEl) timerEl.style.display = 'none';
        }

        function updateTimerDisplay() {
            let timerEl = document.getElementById('timer-display');
            if (!timerEl) return;
            timerEl.style.display = 'block';
            timerEl.textContent = (graceMode ? ' ' : '') + currentTimer + 's';
            timerEl.classList.remove('warning', 'critical', 'grace');
            if (graceMode) timerEl.classList.add('grace');
            else if (currentTimer <= 10) timerEl.classList.add('critical');
            else if (currentTimer <= 30) timerEl.classList.add('warning');
        }

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        function rgbToHsl(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }
            return [h, s, l];
        }

        function applyBoardTheme() {
            const [r, g, b] = currentBaseColor;
            const [h, s, l] = rgbToHsl(r, g, b);
            
            // Adjust lightness based on slider (0-100, 50 = original)
            const lightnessAdjust = (50 - currentLightness) / 100; // -0.5 to +0.5
            const newL = Math.max(0.1, Math.min(0.9, l + lightnessAdjust));
            
            const [nr, ng, nb] = hslToRgb(h, s, newL);
            const boardColor = `rgb(${nr}, ${ng}, ${nb})`;
            
            // Slightly darker for lines
            const [lr, lg, lb] = hslToRgb(h, s, Math.max(0, newL - 0.1));
            const lineColor = `rgb(${lr}, ${lg}, ${lb})`;
            
            // Apply to CSS variables
            document.documentElement.style.setProperty('--board-bg', boardColor);
            document.documentElement.style.setProperty('--board-lines', lineColor);
            
            // Update all normal cells
            document.querySelectorAll('.cell.normal').forEach(cell => {
                cell.style.background = boardColor;
            });
        }

        function applyPremiumColors() {
            const tw = document.getElementById('tw-color').value;
            const dw = document.getElementById('dw-color').value;
            const tl = document.getElementById('tl-color').value;
            const dl = document.getElementById('dl-color').value;
            
            document.documentElement.style.setProperty('--triple-word', tw);
            document.documentElement.style.setProperty('--double-word', dw);
            document.documentElement.style.setProperty('--triple-letter', tl);
            document.documentElement.style.setProperty('--double-letter', dl);
            document.documentElement.style.setProperty('--center-bg', dw);
            
            // Update existing cells
            document.querySelectorAll('.cell.TW').forEach(c => c.style.background = tw);
            document.querySelectorAll('.cell.DW').forEach(c => c.style.background = dw);
            document.querySelectorAll('.cell.TL').forEach(c => c.style.background = tl);
            document.querySelectorAll('.cell.DL').forEach(c => c.style.background = dl);
            document.querySelectorAll('.cell.center').forEach(c => c.style.background = dw);
            
            // Update labels
            document.querySelector('.premium-label.tw').style.background = tw;
            document.querySelector('.premium-label.dw').style.background = dw;
            document.querySelector('.premium-label.tl').style.background = tl;
            document.querySelector('.premium-label.dl').style.background = dl;
        }

        // Color preset clicks
        document.querySelectorAll('.color-preset').forEach(preset => {
            preset.addEventListener('click', () => {
                document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
                preset.classList.add('active');
                
                const rgb = preset.dataset.color.split(',').map(Number);
                currentBaseColor = rgb;
                
                // Update color picker to match
                const hex = '#' + rgb.map(c => c.toString(16).padStart(2, '0')).join('');
                document.getElementById('board-color-picker').value = hex;
                document.getElementById('color-picker-btn').style.background = hex;
                
                applyBoardTheme();
            });
        });

        // Custom color picker
        document.getElementById('board-color-picker').addEventListener('input', (e) => {
            const hex = e.target.value;
            document.getElementById('color-picker-btn').style.background = hex;
            
            // Parse hex to RGB
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            currentBaseColor = [r, g, b];
            
            // Deselect presets
            document.querySelectorAll('.color-preset').forEach(p => p.classList.remove('active'));
            
            applyBoardTheme();
        });

        // Lightness slider
        document.getElementById('lightness-slider').addEventListener('input', (e) => {
            currentLightness = parseInt(e.target.value);
            applyBoardTheme();
        });

        // Premium color pickers
        ['tw', 'dw', 'tl', 'dl'].forEach(type => {
            document.getElementById(`${type}-color`).addEventListener('input', applyPremiumColors);
        });

        function initGame() {
            // CRITICAL: Disable validation during init to prevent tile accumulation
            isInitializingGame = true;
            turnStartTiles = [];
            isValidatingTiles = false;
            
            // CRITICAL: Reset racks to empty arrays FIRST
            racks = [[], []];
            
            debugLog = []; // Clear log on new game
            log('GAME', 'Initializing new game');
            board = Array(15).fill(null).map(() => Array(15).fill(null));
            scores = [0, 0]; currentPlayer = 1; placedThisTurn = []; isFirstMove = true;
            initBag();
            log('GAME', 'Bag initialized', { bagCount: bag.length });
            initBoard();
            
            // Draw exactly 7 tiles for each player
            const rack1 = drawTiles(7);
            const rack2 = drawTiles(7);
            log('GAME', 'Drew tiles', { rack1Count: rack1.length, rack2Count: rack2.length, bagAfter: bag.length });
            
            // Assign racks - should be exactly 7 tiles each
            racks = [rack1, rack2];
            log('GAME', 'Racks assigned', { rack1Count: racks[0].length, rack2Count: racks[1].length });
            
            recentlyPlayedWords = [];
            wordHistory = [];
            
            // NOW save turn start tiles (exactly 7 tiles)
            saveTurnStartTiles();
            
            // Re-enable validation BEFORE updateUI
            isInitializingGame = false;
            
            updateUI();
            updateSavedThemesList();
            applyBoardTheme();
            
            log('GAME', 'Game initialized complete', { rack1Count: racks[0].length, rack2Count: racks[1].length, bagCount: bag.length });
        }

        // ============== WebSocket & Multiplayer Functions ==============
        
        function lobbyStatus(msg) {
            const el = document.getElementById('lobby-status');
            if (el) {
                el.textContent = msg;
                el.style.color = msg.includes('') ? '#4ade80' : msg.includes('') ? '#f87171' : '#888';
            }
            console.log('[LOBBY]', msg);
        }
        
        function connectSocket() {
            if (socket && socket.connected) {
                lobbyStatus('Already connected');
                return;
            }
            
            const serverUrl = window.location.origin;
            lobbyStatus('Connecting to ' + serverUrl + '...');
            
            socket = io(serverUrl, {
                transports: ['websocket', 'polling'],
                timeout: 20000,
                reconnection: true,
                reconnectionAttempts: 10,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000
            });
            
            socket.on('connect', () => {
                log('SOCKET', 'Connected to server', { sid: socket.id });
                playerId = socket.id;
                lobbyStatus(' Connected! ID: ' + socket.id.substring(0,8));
            });
            
            socket.on('disconnect', (reason) => {
                log('SOCKET', 'Disconnected', reason);
                lobbyStatus(' Disconnected: ' + reason + ' (reconnecting...)');
            });
            
            socket.on('reconnect', (attemptNumber) => {
                log('SOCKET', 'Reconnected after', attemptNumber, 'attempts');
                lobbyStatus(' Reconnected!');
                // Re-join room if we were in one
                if (roomCode && !isBoardViewer) {
                    socket.emit('get_state', { room_code: roomCode });
                }
            });
            
            socket.on('reconnect_attempt', (attemptNumber) => {
                lobbyStatus(' Reconnecting... attempt ' + attemptNumber);
            });
            
            socket.on('reconnect_error', (error) => {
                lobbyStatus(' Reconnect failed');
            });
            
            socket.on('connect_error', (error) => {
                log('SOCKET', 'Connection error', error);
                lobbyStatus(' Connection error (retrying...)');
            });
            
            socket.on('error', (data) => {
                log('SOCKET', 'Error', data);
                lobbyStatus(' Error: ' + (data.message || 'Unknown'));
                showMessage(data.message || 'Connection error', 'error');
                
                // If room not found, clear saved game and show lobby
                if (data.message && data.message.includes('not found')) {
                    clearSavedGame();
                    showLobby();
                }
            });
            
            socket.on('room_created', (data) => {
                log('SOCKET', 'Room created', data);
                lobbyStatus(' Room created: ' + data.room_code);
                roomCode = data.room_code;
                playerId = data.player_id;
                isHost = true;
                allPlayers = data.players;
                saveGameSession();
                showWaitingRoom();
            });
            
            socket.on('room_joined', (data) => {
                log('SOCKET', 'Room joined', data);
                lobbyStatus(' Joined room: ' + data.room_code);
                roomCode = data.room_code;
                playerId = data.player_id;
                allPlayers = data.players;
                saveGameSession();
                showWaitingRoom();
            });
            
            socket.on('board_joined', (data) => {
                log('SOCKET', 'Board joined', data);
                roomCode = data.room_code;
                isBoardViewer = true;
                allPlayers = data.players;
                document.getElementById('display-room-code-board').textContent = roomCode;
                
                if (data.status === 'playing') {
                    // Game already in progress - show board
                    startMultiplayerGame(data);
                }
            });
            
            socket.on('player_joined', (data) => {
                log('SOCKET', 'Player joined', data);
                allPlayers = data.players;
                updatePlayerList();
            });
            
            socket.on('player_disconnected', (data) => {
                log('SOCKET', 'Player disconnected', data);
                showMessage(`${data.name} disconnected`, 'error');
            });
            
            socket.on('game_started', (data) => {
                log('SOCKET', 'Game started!', data);
                startMultiplayerGame(data);
            });
            
            socket.on('move_played', (data) => {
                log('SOCKET', 'Move played', data);
                handleMoveUpdate(data);
            });
            
            socket.on('move_rejected', (data) => {
                log('SOCKET', 'Move rejected', data);
                showMessage(data.message || 'Move rejected!', 'error');
                
                // Shake placed tiles then recall them
                const placedTileElements = document.querySelectorAll('.tile.placed-this-turn');
                placedTileElements.forEach(tile => {
                    tile.classList.add('shake');
                });
                
                // After shake, disintegrate and recall
                setTimeout(() => {
                    placedTileElements.forEach(tile => {
                        tile.classList.remove('shake');
                        tile.classList.add('disintegrate');
                    });
                    
                    // After disintegrate animation, recall tiles
                    setTimeout(() => {
                        recallTiles();
                    }, 400);
                }, 500);
            });
            
            socket.on('turn_passed', (data) => {
                log('SOCKET', 'Turn passed', data);
                handleTurnPassed(data);
            });
            
            socket.on('game_state', (data) => {
                log('SOCKET', 'Game state received', data);
                handleGameState(data);
            });
        }
        
        function showLobby() {
            document.getElementById('lobby-overlay').classList.remove('hidden');
            document.getElementById('lobby-main').style.display = 'block';
            document.getElementById('lobby-menu').style.display = 'none';
            document.getElementById('lobby-waiting').style.display = 'none';
            document.getElementById('lobby-board-view').style.display = 'none';
            
            // Load saved name
            const savedName = localStorage.getItem('scrabble_player_name') || '';
            document.getElementById('player-name-input').value = savedName;
            
            // Check for saved game to rejoin
            const savedRoom = localStorage.getItem('scrabble_room_code');
            const rejoinSection = document.getElementById('rejoin-section');
            if (savedRoom) {
                rejoinSection.style.display = 'block';
                document.getElementById('rejoin-code').textContent = savedRoom;
            } else {
                rejoinSection.style.display = 'none';
            }
            
            lobbyStatus('Ready to play...');
        }
        
        function showMultiplayerMenu() {
            document.getElementById('lobby-main').style.display = 'none';
            document.getElementById('lobby-menu').style.display = 'block';
            
            // Reset buttons
            const createBtn = document.getElementById('btn-create-room');
            createBtn.disabled = false;
            createBtn.textContent = ' Create Room';
            
            const joinBtn = document.getElementById('btn-join-room');
            joinBtn.disabled = false;
            joinBtn.textContent = 'Join Game';
            
            const boardBtn = document.getElementById('btn-join-board');
            boardBtn.disabled = false;
            boardBtn.textContent = ' Join as Display Board';
            
            lobbyStatusMP('Ready to connect...');
        }
        
        function lobbyStatusMP(msg) {
            const el = document.getElementById('lobby-status-mp');
            if (el) el.textContent = msg;
            console.log('[LOBBY-MP]', msg);
        }
        
        function hideLobby() {
            document.getElementById('lobby-overlay').classList.add('hidden');
        }
        
        function showWaitingRoom() {
            document.getElementById('lobby-main').style.display = 'none';
            document.getElementById('lobby-menu').style.display = 'none';
            document.getElementById('lobby-waiting').style.display = 'block';
            document.getElementById('lobby-board-view').style.display = 'none';
            
            document.getElementById('display-room-code').textContent = roomCode;
            document.getElementById('btn-start-game').style.display = isHost ? 'block' : 'none';
            
            updatePlayerList();
        }
        
        function updatePlayerList() {
            const container = document.getElementById('player-list-items');
            container.innerHTML = '';
            
            allPlayers.forEach((p, idx) => {
                const item = document.createElement('div');
                item.className = 'player-item';
                item.innerHTML = `
                    <div class="player-icon">${p.name.charAt(0).toUpperCase()}</div>
                    <div class="player-name">${p.name}${p.id === playerId ? ' (You)' : ''}</div>
                    ${idx === 0 ? '<span class="player-host">HOST</span>' : ''}
                `;
                container.appendChild(item);
            });
            
            document.getElementById('player-count').textContent = allPlayers.length;
            document.getElementById('waiting-message').textContent = 
                allPlayers.length < 2 ? 'Waiting for players...' : 
                isHost ? 'Ready to start!' : 'Waiting for host to start...';
            
            // Show start button for host when 2+ players
            if (isHost) {
                document.getElementById('btn-start-game').style.display = 
                    allPlayers.length >= 2 ? 'block' : 'none';
            }
        }
        
        function createRoom() {
            const btn = document.getElementById('btn-create-room');
            btn.disabled = true;
            btn.textContent = ' Connecting...';
            
            playerName = document.getElementById('player-name-input').value.trim() || 'Player';
            localStorage.setItem('scrabble_player_name', playerName);
            
            lobbyStatusMP(' Connecting...');
            connectSocket();
            
            // Wait for connection then create room
            let attempts = 0;
            const tryCreate = () => {
                attempts++;
                if (socket && socket.connected) {
                    lobbyStatusMP(' Creating room as ' + playerName + '...');
                    btn.textContent = ' Creating...';
                    socket.emit('create_room', { name: playerName });
                } else if (attempts < 50) {
                    lobbyStatusMP(' Waiting for connection... (' + attempts + ')');
                    setTimeout(tryCreate, 100);
                } else {
                    lobbyStatusMP(' Could not connect to server');
                    btn.disabled = false;
                    btn.textContent = ' Create Room';
                }
            };
            tryCreate();
        }
        
        function joinRoom(asBoard = false) {
            const code = document.getElementById('room-code-input').value.trim().toUpperCase();
            if (code.length !== 4) {
                lobbyStatusMP(' Enter 4-letter room code');
                return;
            }
            
            const btn = asBoard ? document.getElementById('btn-join-board') : document.getElementById('btn-join-room');
            btn.disabled = true;
            btn.textContent = ' Connecting...';
            
            playerName = document.getElementById('player-name-input').value.trim() || 'Player';
            localStorage.setItem('scrabble_player_name', playerName);
            
            lobbyStatusMP(' Connecting...');
            connectSocket();
            
            let attempts = 0;
            const tryJoin = () => {
                attempts++;
                if (socket && socket.connected) {
                    lobbyStatusMP(' Joining room ' + code + '...');
                    btn.textContent = ' Joining...';
                    socket.emit('join_room', { 
                        room_code: code, 
                        name: playerName,
                        mode: asBoard ? 'board' : 'player'
                    });
                    
                    if (asBoard) {
                        document.getElementById('lobby-menu').style.display = 'none';
                        document.getElementById('lobby-board-view').style.display = 'block';
                        document.getElementById('display-room-code-board').textContent = code;
                    }
                } else if (attempts < 50) {
                    lobbyStatusMP(' Waiting for connection... (' + attempts + ')');
                    setTimeout(tryJoin, 100);
                } else {
                    lobbyStatusMP(' Could not connect to server');
                    btn.disabled = false;
                    btn.textContent = asBoard ? ' Join as Display Board' : 'Join Game';
                }
            };
            tryJoin();
        }
        
        function startMultiplayerGameFromLobby() {
            if (!isHost) return;
            socket.emit('start_game', { room_code: roomCode });
        }
        
        function leaveRoom() {
            if (socket) {
                socket.disconnect();
            }
            multiplayerMode = false;
            roomCode = null;
            isHost = false;
            isBoardViewer = false;
            allPlayers = [];
            clearSavedGame();
            showLobby();
        }
        
        function startMultiplayerGame(data) {
            multiplayerMode = true;
            gameMode = 'multiplayer'; // Prevent AI from playing
            hideLobby();
            
            // Reset game state
            board = Array(15).fill(null).map(() => Array(15).fill(null));
            placedThisTurn = [];
            isFirstMove = true;
            wordHistory = [];
            recentlyPlayedWords = [];
            
            // Apply board state if provided - server sends strings, we need objects
            if (data.board) {
                for (let r = 0; r < 15; r++) {
                    for (let c = 0; c < 15; c++) {
                        const cell = data.board[r][c];
                        if (cell) {
                            if (typeof cell === 'string') {
                                board[r][c] = { letter: cell, isBlank: false };
                            } else if (cell.letter) {
                                board[r][c] = { letter: cell.letter, isBlank: cell.isBlank || false };
                            } else {
                                board[r][c] = cell;
                            }
                            isFirstMove = false;
                        }
                    }
                }
            }
            
            // Set our rack (if we're a player, not board viewer)
            if (data.your_rack && !isBoardViewer) {
                racks[0] = [...data.your_rack];
            } else {
                racks[0] = [];
            }
            racks[1] = []; // We don't see opponent's rack
            
            // Update players
            allPlayers = data.players || [];
            currentPlayerIdx = data.current_player_idx || 0;
            
            // Determine if it's our turn
            const currentPlayerId = data.current_player_id || (allPlayers[currentPlayerIdx]?.id);
            isMyTurn = currentPlayerId === playerId;
            
            // Update scores display
            updateMultiplayerScores();
            
            // Update turn indicator
            updateTurnIndicator();
            
            // Hide AI stuff, show multiplayer indicator
            document.querySelectorAll('.ai-response-box').forEach(el => el.style.display = 'none');
            document.getElementById('ai-thinking').style.display = 'none';
            document.getElementById('ai-status').style.display = 'none';
            
            // Init board and render
            initBoard();
            renderRack();
            applyBoardTheme(); // Apply saved theme
            
            // Disable/enable controls based on turn
            updateControlsForTurn();
            
            log('MULTIPLAYER', 'Game started', { 
                isMyTurn, 
                rackCount: racks[0].length, 
                players: allPlayers.length,
                isBoardViewer 
            });
        }
        
        function handleMoveUpdate(data) {
            log('MULTIPLAYER', 'handleMoveUpdate received', { hasBoardData: !!data.board, hasRack: !!data.your_rack });
            
            // Update board - server sends strings, we need objects
            if (data.board) {
                let tilesInData = 0;
                for (let r = 0; r < 15; r++) {
                    for (let c = 0; c < 15; c++) {
                        const cell = data.board[r][c];
                        if (cell) {
                            tilesInData++;
                            // Convert string to object format
                            if (typeof cell === 'string') {
                                board[r][c] = { letter: cell, isBlank: false };
                            } else if (cell.letter) {
                                board[r][c] = { letter: cell.letter, isBlank: cell.isBlank || false };
                            } else {
                                board[r][c] = cell;
                            }
                        } else {
                            board[r][c] = null;
                        }
                    }
                }
                log('MULTIPLAYER', 'Board data processed', { tilesInData });
            }
            isFirstMove = false;
            
            // Update our rack (if provided)
            if (data.your_rack && !isBoardViewer) {
                racks[0] = [...data.your_rack];
                log('MULTIPLAYER', 'Updated rack', { tiles: racks[0] });
            }
            
            // Update players/scores
            if (data.players) {
                allPlayers = data.players;
                updateMultiplayerScores();
            }
            
            // Update current player
            currentPlayerIdx = data.current_player_idx;
            isMyTurn = data.current_player_id === playerId;
            
            // Show last move
            if (data.last_move) {
                const move = data.last_move;
                showMessage(`${move.player_name}: ${move.words.join(', ')} (+${move.score})`, 'success');
                
                // Add to word history
                move.words.forEach(w => {
                    wordHistory.unshift({ word: w, score: move.score, player: move.player_name });
                });
                if (wordHistory.length > 10) wordHistory.length = 10;
            }
            
            // Clear placed tiles (they're now permanent)
            placedThisTurn = [];
            
            // Re-render board and rack
            log('MULTIPLAYER', 'About to re-render board');
            initBoard();
            renderRack();
            applyBoardTheme();
            updateTurnIndicator();
            updateControlsForTurn();
            
            // Verify render worked
            const boardTileCount = document.querySelectorAll('.board .tile').length;
            log('MULTIPLAYER', 'Board updated', { isMyTurn, rackCount: racks[0].length, tilesOnBoard: boardTileCount });
            
            // Check game over
            if (data.game_over) {
                handleGameOver();
            }
        }
        
        function handleTurnPassed(data) {
            showMessage(`${data.player_name} passed`, 'info');
            
            if (data.players) {
                allPlayers = data.players;
                updateMultiplayerScores();
            }
            
            currentPlayerIdx = data.current_player_idx;
            isMyTurn = data.current_player_id === playerId;
            
            updateTurnIndicator();
            updateControlsForTurn();
            
            if (data.game_over) {
                handleGameOver();
            }
        }
        
        function handleGameState(data) {
            // Reconnection handler
            startMultiplayerGame(data);
        }
        
        function updateMultiplayerScores() {
            // For multiplayer, create a dynamic score display for all players
            const scoreContainer = document.getElementById('player1-score').parentElement;
            
            // Clear existing scores
            scoreContainer.innerHTML = '';
            
            // Create compact score row for each player
            allPlayers.forEach((player, idx) => {
                const isMe = player.id === playerId;
                const isCurrent = idx === currentPlayerIdx;
                
                const row = document.createElement('div');
                row.className = 'score-row' + (isCurrent ? ' current' : '');
                row.id = `player${idx + 1}-score`;
                row.style.cssText = 'padding:2px 4px; font-size:11px; display:flex; align-items:center; gap:4px;';
                
                // Shorter name display
                const displayName = player.name.length > 8 ? player.name.substring(0,7) + '' : player.name;
                
                row.innerHTML = `
                    <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-size:11px;">
                        ${isCurrent ? '' : ''} ${displayName}${isMe ? '(me)' : ''}
                    </span>
                    <span class="score" style="font-weight:bold;font-size:14px;min-width:25px;text-align:right;">${player.score}</span>
                `;
                if (isCurrent) {
                    row.style.background = 'rgba(74, 222, 128, 0.2)';
                    row.style.borderLeft = '2px solid #4ade80';
                }
                scoreContainer.appendChild(row);
            });
        }
        
        function updateTurnIndicator() {
            const indicator = document.getElementById('turn-indicator');
            if (isBoardViewer) {
                const currentP = allPlayers[currentPlayerIdx];
                indicator.textContent = currentP ? `${currentP.name}'s turn` : 'Waiting...';
            } else if (isMyTurn) {
                indicator.textContent = ' Your turn!';
                indicator.style.color = '#4ade80';
            } else {
                const currentP = allPlayers[currentPlayerIdx];
                indicator.textContent = currentP ? `${currentP.name}'s turn` : 'Waiting...';
                indicator.style.color = '#888';
            }
        }
        
        function updateControlsForTurn() {
            const playBtn = document.getElementById('btn-play');
            const recallBtn = document.getElementById('btn-recall');
            const shuffleBtn = document.getElementById('btn-shuffle');
            const passBtn = document.getElementById('btn-pass');
            
            const enabled = isMyTurn && !isBoardViewer;
            
            if (playBtn) playBtn.disabled = !enabled;
            if (recallBtn) recallBtn.disabled = !enabled;
            if (shuffleBtn) shuffleBtn.disabled = !enabled;
            if (passBtn) passBtn.disabled = !enabled;
            
            // Also disable tile interactions if not our turn
            if (!enabled) {
                deselectTile();
            }
        }
        
        function handleGameOver() {
            // Find winner
            const winner = allPlayers.reduce((a, b) => a.score > b.score ? a : b);
            const isWinner = winner.id === playerId;
            
            showMessage(
                isWinner ? ` You win with ${winner.score} points!` : 
                `Game over! ${winner.name} wins with ${winner.score} points!`,
                isWinner ? 'success' : 'info'
            );
            
            // Clear saved game so refresh doesn't try to rejoin
            clearSavedGame();
        }
        
        // Override playWord for multiplayer
        const originalPlayWord = typeof playWord === 'function' ? playWord : null;
        
        function playWordMultiplayer() {
            if (!multiplayerMode) {
                if (originalPlayWord) originalPlayWord();
                return;
            }
            
            if (!isMyTurn) {
                showMessage("Not your turn!", 'error');
                return;
            }
            
            if (placedThisTurn.length === 0) {
                showMessage("Place some tiles first!", 'error');
                return;
            }
            
            // Get words formed (similar to single player validation)
            const wordsFormed = getWordsFormed();
            log('MULTIPLAYER', 'Words formed', { words: wordsFormed, placedTiles: placedThisTurn.length });
            
            if (!wordsFormed || wordsFormed.length === 0) {
                showMessage("No valid word formed!", 'error');
                return;
            }
            
            // Calculate score
            const score = calculateMoveScore();
            
            log('MULTIPLAYER', 'Sending play_move', { words: wordsFormed, score, tiles: placedThisTurn.length });
            
            // Send to server
            socket.emit('play_move', {
                room_code: roomCode,
                tiles: placedThisTurn.map(p => ({
                    row: p.row,
                    col: p.col,
                    letter: p.letter,
                    is_blank: p.originalLetter === '?'
                })),
                words: wordsFormed,
                score: score
            });
        }
        
        function passMultiplayer() {
            if (!multiplayerMode) {
                pass();
                return;
            }
            
            if (!isMyTurn) {
                showMessage("Not your turn!", 'error');
                return;
            }
            
            // Recall tiles first
            recallTiles();
            
            socket.emit('pass_turn', { room_code: roomCode });
        }
        
        function getWordsFormed() {
            // Collect all words formed by current placement
            const words = [];
            
            if (placedThisTurn.length === 0) return words;
            
            // Determine direction
            const rows = placedThisTurn.map(p => p.row);
            const cols = placedThisTurn.map(p => p.col);
            const isHorizontal = new Set(rows).size === 1;
            const isVertical = new Set(cols).size === 1;
            
            if (!isHorizontal && !isVertical && placedThisTurn.length > 1) {
                return null; // Invalid placement
            }
            
            // Get main word
            const mainWord = getWordAt(placedThisTurn[0].row, placedThisTurn[0].col, isHorizontal ? 'H' : 'V');
            if (mainWord && mainWord.length >= 2) {
                words.push(mainWord);
            }
            
            // Get cross words
            placedThisTurn.forEach(p => {
                const crossDir = isHorizontal ? 'V' : 'H';
                const crossWord = getWordAt(p.row, p.col, crossDir);
                if (crossWord && crossWord.length >= 2 && !words.includes(crossWord)) {
                    words.push(crossWord);
                }
            });
            
            return words;
        }
        
        function getWordAt(row, col, direction) {
            let word = '';
            let r = row, c = col;
            const dr = direction === 'V' ? 1 : 0;
            const dc = direction === 'H' ? 1 : 0;
            
            // Helper to get letter from cell (handles both string and object)
            const getLetter = (cell) => {
                if (!cell) return null;
                if (typeof cell === 'string') return cell;
                if (cell.letter) return cell.letter;
                return null;
            };
            
            // Go to start
            while (r - dr >= 0 && c - dc >= 0 && getLetter(board[r - dr][c - dc])) {
                r -= dr;
                c -= dc;
            }
            
            // Build word
            while (r < 15 && c < 15 && getLetter(board[r][c])) {
                word += getLetter(board[r][c]);
                r += dr;
                c += dc;
            }
            
            return word;
        }
        
        function calculateMoveScore() {
            // Simplified score calculation - server will validate
            let score = 0;
            placedThisTurn.forEach(p => {
                score += LETTER_VALUES[p.originalLetter] || LETTER_VALUES[p.letter] || 0;
            });
            // Add multipliers (simplified)
            return score;
        }
        
        // ============== Lobby Event Listeners ==============
        
        // Main menu buttons
        document.getElementById('btn-play-ai').addEventListener('click', () => {
            playerName = document.getElementById('player-name-input').value.trim() || 'Player';
            localStorage.setItem('scrabble_player_name', playerName);
            multiplayerMode = false;
            gameMode = 'ai';
            clearSavedGame();
            hideLobby();
            initGame();
        });
        
        document.getElementById('btn-multiplayer').addEventListener('click', () => {
            playerName = document.getElementById('player-name-input').value.trim() || 'Player';
            localStorage.setItem('scrabble_player_name', playerName);
            showMultiplayerMenu();
        });
        
        document.getElementById('btn-rejoin').addEventListener('click', rejoinSavedGame);
        
        document.getElementById('btn-clear-saved').addEventListener('click', () => {
            clearSavedGame();
            document.getElementById('rejoin-section').style.display = 'none';
            lobbyStatus('Saved game cleared');
        });
        
        // Multiplayer menu buttons
        document.getElementById('btn-create-room').addEventListener('click', createRoom);
        document.getElementById('btn-join-room').addEventListener('click', () => joinRoom(false));
        document.getElementById('btn-join-board').addEventListener('click', () => joinRoom(true));
        document.getElementById('btn-back-main').addEventListener('click', showLobby);
        
        // Waiting room buttons
        document.getElementById('btn-start-game').addEventListener('click', startMultiplayerGameFromLobby);
        document.getElementById('btn-leave-room').addEventListener('click', leaveRoom);
        document.getElementById('btn-leave-board').addEventListener('click', leaveRoom);
        
        // Room code input - auto uppercase
        document.getElementById('room-code-input').addEventListener('input', (e) => {
            e.target.value = e.target.value.toUpperCase();
        });
        
        // Override play button for multiplayer
        const playBtn = document.getElementById('btn-play');
        if (playBtn) {
            playBtn.removeEventListener('click', playWord);
            playBtn.addEventListener('click', () => {
                if (multiplayerMode) {
                    playWordMultiplayer();
                } else {
                    playWord();
                }
            });
        }
        
        // Override pass button for multiplayer
        const passBtn = document.getElementById('btn-pass');
        if (passBtn) {
            const originalPass = pass;
            passBtn.addEventListener('click', () => {
                if (multiplayerMode) {
                    passMultiplayer();
                } else {
                    originalPass();
                }
            });
        }
        
        // ============== Game Session Management ==============
        
        function saveGameSession() {
            if (roomCode) {
                localStorage.setItem('scrabble_room_code', roomCode);
                localStorage.setItem('scrabble_player_name', playerName);
            }
        }
        
        function clearSavedGame() {
            localStorage.removeItem('scrabble_room_code');
        }
        
        function rejoinSavedGame() {
            const savedRoom = localStorage.getItem('scrabble_room_code');
            const savedName = localStorage.getItem('scrabble_player_name');
            
            if (!savedRoom) {
                lobbyStatus(' No saved game found');
                return;
            }
            
            lobbyStatus(' Reconnecting to room ' + savedRoom + '...');
            playerName = savedName || document.getElementById('player-name-input').value.trim() || 'Player';
            roomCode = savedRoom;
            
            connectSocket();
            
            let attempts = 0;
            const tryRejoin = () => {
                attempts++;
                if (socket && socket.connected) {
                    lobbyStatus(' Rejoining room ' + savedRoom + '...');
                    socket.emit('join_room', { 
                        room_code: savedRoom, 
                        name: playerName,
                        mode: 'player'
                    });
                } else if (attempts < 30) {
                    setTimeout(tryRejoin, 100);
                } else {
                    lobbyStatus(' Could not connect to server');
                }
            };
            tryRejoin();
        }
        
        // Start by showing lobby (no auto-rejoin)
        showLobby();
    </script>
</body>
</html>
