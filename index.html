<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scrabble</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --board-bg: #b8b896;
            --board-lines: #a0a080;
            --triple-word: #e85a70;
            --triple-word-text: #fff;
            --double-word: #f0b8bc;
            --double-word-text: #8b4a52;
            --triple-letter: #5eb3d0;
            --triple-letter-text: #1a4a5c;
            --double-letter: #a8d8ea;
            --double-letter-text: #2a6080;
            --center-bg: #f0b8bc;
            --center-star: #c45a68;
            --frame-dark: #5c4a3a;
            --frame-mid: #7a6352;
            --frame-light: #96806c;
            --frame-accent: #c9a227;
            --tile-border: #a07050;
            --tile-border-light: #c89878;
            --tile-face-1: #e8cdb8;
            --tile-face-2: #dfc0a8;
            --tile-face-3: #d4b090;
            --tile-face-4: #c8a078;
            --tile-text: #2a2018;
            --text-light: #f5f0e6;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(145deg, #2d2d2d 0%, #1a1a1a 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
            color: var(--text-light);
        }

        h1 {
            color: var(--frame-accent);
            font-size: 1.8rem;
            letter-spacing: 6px;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .mode-btn {
            padding: 6px 14px;
            border-radius: 20px;
            border: 2px solid var(--frame-mid);
            background: transparent;
            color: var(--text-light);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-btn:hover, .mode-btn.active {
            background: var(--frame-accent);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            flex-wrap: wrap;
            justify-content: center;
        }

        .board-frame {
            background: linear-gradient(145deg, var(--frame-light), var(--frame-dark));
            padding: 12px;
            border-radius: 6px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.5);
        }

        .board-inner {
            background: var(--board-lines);
            padding: 2px;
            border-radius: 3px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(15, 32px);
            gap: 2px;
        }

        .cell {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 4px;
            font-weight: 700;
            text-transform: uppercase;
            line-height: 1.1;
            text-align: center;
            border-radius: 1px;
            position: relative;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .cell.normal { background: var(--board-bg); }
        .cell.DL { background: var(--double-letter); color: var(--double-letter-text); }
        .cell.TL { background: var(--triple-letter); color: var(--triple-letter-text); }
        .cell.DW { background: var(--double-word); color: var(--double-word-text); }
        .cell.TW { background: var(--triple-word); color: var(--triple-word-text); }
        .cell.center { background: var(--center-bg); }
        .cell.center .star { font-size: 14px; color: var(--center-star); }

        .cell.selected {
            box-shadow: inset 0 0 0 2px var(--frame-accent), 0 0 10px rgba(201,162,39,0.5);
        }

        .cell.typing-start {
            box-shadow: inset 0 0 0 3px #4ade80;
        }

        .cell .premium-text {
            font-size: 4px;
            font-weight: 700;
            line-height: 1.1;
            pointer-events: none;
        }

        .tile {
            width: 28px;
            height: 28px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            cursor: grab;
            user-select: none;
            background: linear-gradient(160deg, var(--tile-border-light), var(--tile-border));
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            z-index: 10;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .tile::before {
            content: '';
            position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            border-radius: 2px;
            background: 
                repeating-linear-gradient(95deg, transparent 0px, transparent 3px, rgba(160,120,80,0.08) 3px, rgba(160,120,80,0.08) 4px),
                linear-gradient(165deg, var(--tile-face-1), var(--tile-face-2) 30%, var(--tile-face-3) 70%, var(--tile-face-4));
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.7), inset 0 -1px 2px rgba(0,0,0,0.1);
        }

        .tile .letter {
            position: relative;
            z-index: 2;
            font-size: 16px;
            font-weight: 700;
            color: var(--tile-text);
        }

        .tile .points {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 6px;
            font-weight: 600;
            color: var(--tile-text);
            z-index: 2;
        }

        .tile.selected {
            transform: scale(1.1);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 3px var(--frame-accent);
        }

        .tile.placed-this-turn {
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4), 0 0 0 2px var(--frame-accent);
            cursor: pointer;
        }

        .tile.dragging { opacity: 0.7; cursor: grabbing; }

        /* Floating tile that follows cursor */
        .tile.floating {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%) scale(1.15);
            box-shadow: 4px 6px 12px rgba(0,0,0,0.5), 0 0 0 3px var(--frame-accent);
        }

        /* Direction arrow indicator */
        .direction-arrow {
            position: absolute;
            font-size: 18px;
            color: #4ade80;
            z-index: 5;
            text-shadow: 0 0 4px rgba(74,222,128,0.8);
            animation: pulse 1s ease infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .cell.can-drop {
            background: rgba(74,222,128,0.3) !important;
        }

        .rack-area { display: flex; flex-direction: column; gap: 10px; }

        .rack-frame {
            background: linear-gradient(145deg, var(--frame-light), var(--frame-dark));
            padding: 8px 12px;
            border-radius: 6px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        }

        .rack-label {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-bottom: 5px;
            text-align: center;
        }

        .rack {
            background: var(--frame-mid);
            padding: 6px 8px;
            border-radius: 4px;
            display: flex;
            gap: 4px;
            box-shadow: inset 0 2px 6px rgba(0,0,0,0.4);
            min-width: 240px;
            min-height: 42px;
            justify-content: center;
            align-items: center;
        }

        .btn-group {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            background: linear-gradient(145deg, var(--frame-light), var(--frame-dark));
            color: var(--text-light);
            border: 1px solid var(--frame-mid);
            padding: 8px 14px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }

        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn.primary {
            background: linear-gradient(145deg, var(--frame-accent), #a68520);
            color: #1a1a1a;
            border-color: var(--frame-accent);
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 160px;
        }

        .info-box {
            background: rgba(0,0,0,0.3);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.05);
        }

        .info-box h3 {
            color: var(--frame-accent);
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 2px;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 13px;
        }

        .score-row.current { color: var(--frame-accent); }
        .score-row .score { font-weight: 700; }

        .word-preview {
            min-height: 24px;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
        }

        .word-chip {
            background: rgba(255,255,255,0.1);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
        }

        .word-chip.valid { background: rgba(46,160,67,0.3); color: #4ade80; }
        .word-chip.invalid { background: rgba(220,38,38,0.3); color: #f87171; }

        .message {
            text-align: center;
            padding: 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }

        .message.error { background: rgba(220,38,38,0.2); color: #f87171; }
        .message.success { background: rgba(46,160,67,0.2); color: #4ade80; }
        .message.info { background: rgba(59,130,246,0.2); color: #60a5fa; }

        .typing-input { position: fixed; top: -100px; opacity: 0; }

        .keyboard-hint {
            font-size: 10px;
            opacity: 0.6;
            text-align: center;
            padding: 5px;
        }

        .ai-thinking {
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
            padding: 10px;
            color: var(--frame-accent);
        }

        .spinner {
            width: 16px;
            height: 16px;
            border: 2px solid var(--frame-mid);
            border-top-color: var(--frame-accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .difficulty-select {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid var(--frame-mid);
            background: var(--frame-dark);
            color: var(--text-light);
            font-size: 11px;
        }

        @media (max-width: 700px) {
            .game-container { flex-direction: column; }
            .board { grid-template-columns: repeat(15, 22px); }
            .cell { width: 22px; height: 22px; font-size: 3px; }
            .tile { width: 20px; height: 20px; }
            .tile .letter { font-size: 11px; }
            .tile .points { font-size: 5px; }
            .side-panel { width: 100%; flex-direction: row; flex-wrap: wrap; justify-content: center; }
        }
    </style>
</head>
<body>
    <h1>SCRABBLE</h1>

    <div class="mode-selector">
        <button class="mode-btn active" data-mode="2player">2 Player</button>
        <button class="mode-btn" data-mode="ai">vs AI</button>
        <select class="difficulty-select" id="difficulty" style="display:none;">
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="hard" selected>Hard</option>
        </select>
    </div>

    <div class="game-container">
        <div class="side-panel">
            <div class="info-box">
                <h3>Score</h3>
                <div class="score-row current" id="player1-score">
                    <span id="player1-name">You</span>
                    <span class="score">0</span>
                </div>
                <div class="score-row" id="player2-score">
                    <span id="player2-name">Player 2</span>
                    <span class="score">0</span>
                </div>
            </div>

            <div class="info-box">
                <h3>Turn</h3>
                <div id="turn-indicator" style="font-size:12px;">Your turn</div>
            </div>

            <div class="info-box">
                <h3>Words</h3>
                <div class="word-preview" id="word-preview">
                    <span style="opacity:0.5;font-size:10px;">Place tiles</span>
                </div>
            </div>

            <div class="info-box">
                <h3>Move</h3>
                <div class="score-row">
                    <span>Points</span>
                    <span class="score" id="move-score">0</span>
                </div>
            </div>

            <div style="text-align:center;opacity:0.6;font-size:11px;">
                Bag: <strong id="bag-count">86</strong>
            </div>
        </div>

        <div>
            <div class="board-frame">
                <div class="board-inner">
                    <div class="board" id="board"></div>
                </div>
            </div>

            <div class="rack-area">
                <div class="rack-frame">
                    <div class="rack-label" id="rack-label">Your Rack</div>
                    <div class="rack" id="rack"></div>
                </div>

                <div class="keyboard-hint" id="keyboard-hint">
                    Click tile → click cell, OR click cell → type word
                </div>

                <div class="btn-group">
                    <button class="btn primary" id="btn-play" disabled>Play</button>
                    <button class="btn" id="btn-recall">Recall</button>
                    <button class="btn" id="btn-shuffle">Shuffle</button>
                    <button class="btn" id="btn-hint">Hint</button>
                    <button class="btn" id="btn-pass">Pass</button>
                </div>

                <div id="message" class="message" style="display:none;"></div>
                <div id="ai-thinking" class="ai-thinking" style="display:none;">
                    <div class="spinner"></div>
                    <span>AI thinking...</span>
                </div>
            </div>
        </div>
    </div>

    <input type="text" class="typing-input" id="typing-input" autocomplete="off">
    <div class="tile floating" id="floating-tile" style="display:none;">
        <span class="letter"></span>
        <span class="points"></span>
    </div>

    <script>
        const BOARD_SIZE = 15;
        const LETTER_VALUES = {A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10,'?':0};
        const TILE_COUNTS = {A:9,B:2,C:2,D:4,E:12,F:2,G:3,H:2,I:9,J:1,K:1,L:4,M:2,N:6,O:8,P:2,Q:1,R:6,S:4,T:6,U:4,V:2,W:2,X:1,Y:2,Z:1,'?':2};
        const TW = [[0,0],[0,7],[0,14],[7,0],[7,14],[14,0],[14,7],[14,14]];
        const DW = [[1,1],[2,2],[3,3],[4,4],[1,13],[2,12],[3,11],[4,10],[13,1],[12,2],[11,3],[10,4],[13,13],[12,12],[11,11],[10,10],[7,7]];
        const TL = [[1,5],[1,9],[5,1],[5,5],[5,9],[5,13],[9,1],[9,5],[9,9],[9,13],[13,5],[13,9]];
        const DL = [[0,3],[0,11],[2,6],[2,8],[3,0],[3,7],[3,14],[6,2],[6,6],[6,8],[6,12],[7,3],[7,11],[8,2],[8,6],[8,8],[8,12],[11,0],[11,7],[11,14],[12,6],[12,8],[14,3],[14,11]];

        let board = Array(15).fill(null).map(() => Array(15).fill(null));
        let bag = [], currentPlayer = 1, scores = [0, 0];
        let racks = [[], []], placedThisTurn = [], isFirstMove = true;
        let selectedTile = null, selectedLetter = null, typingCell = null, typingDirection = null;
        let gameMode = '2player', aiDifficulty = 'hard', draggedTile = null;
        let floatingTile = null;

        function initBag() {
            bag = [];
            for (let letter in TILE_COUNTS) {
                for (let i = 0; i < TILE_COUNTS[letter]; i++) bag.push(letter);
            }
            shuffleArray(bag);
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        function drawTiles(n) { return bag.splice(0, Math.min(n, bag.length)); }
        function getCurrentRack() { return racks[currentPlayer - 1]; }
        function setCurrentRack(r) { racks[currentPlayer - 1] = r; }

        function getCellType(r, c) {
            if (r === 7 && c === 7) return 'center';
            if (TW.some(p => p[0] === r && p[1] === c)) return 'TW';
            if (DW.some(p => p[0] === r && p[1] === c)) return 'DW';
            if (TL.some(p => p[0] === r && p[1] === c)) return 'TL';
            if (DL.some(p => p[0] === r && p[1] === c)) return 'DL';
            return 'normal';
        }

        function createTileElement(letter, inRack = false) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.dataset.letter = letter;
            tile.draggable = inRack;
            tile.innerHTML = `<span class="letter">${letter === '?' ? '' : letter}</span><span class="points">${LETTER_VALUES[letter]}</span>`;
            if (inRack) {
                tile.addEventListener('click', () => handleTileClick(tile));
                tile.addEventListener('dragstart', handleDragStart);
                tile.addEventListener('dragend', handleDragEnd);
            }
            return tile;
        }

        function initBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    const type = getCellType(r, c);
                    cell.className = 'cell ' + type;
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    if (type === 'TW') cell.innerHTML = '<span class="premium-text">TRIPLE<br>WORD</span>';
                    else if (type === 'DW' && !(r === 7 && c === 7)) cell.innerHTML = '<span class="premium-text">DOUBLE<br>WORD</span>';
                    else if (type === 'TL') cell.innerHTML = '<span class="premium-text">TRIPLE<br>LETTER</span>';
                    else if (type === 'DL') cell.innerHTML = '<span class="premium-text">DOUBLE<br>LETTER</span>';
                    else if (type === 'center') cell.innerHTML = '<span class="star">★</span>';
                    cell.addEventListener('click', () => handleCellClick(r, c, cell));
                    cell.addEventListener('dragover', e => { 
                        e.preventDefault(); 
                        const r = parseInt(cell.dataset.row);
                        const c = parseInt(cell.dataset.col);
                        // Allow drop on empty cells or cells with placed-this-turn tiles
                        if (!board[r][c] || placedThisTurn.some(p => p.row === r && p.col === c)) {
                            cell.classList.add('selected'); 
                        }
                    });
                    cell.addEventListener('dragleave', () => cell.classList.remove('selected'));
                    cell.addEventListener('drop', e => { 
                        e.preventDefault(); 
                        cell.classList.remove('selected'); 
                        const r = parseInt(cell.dataset.row);
                        const c = parseInt(cell.dataset.col);
                        
                        if (draggedPlacedTile) {
                            // Relocating a placed tile
                            relocatePlacedTile(r, c);
                        } else if (draggedTile) {
                            // Placing from rack
                            if (!board[r][c] || placedThisTurn.some(p => p.row === r && p.col === c)) {
                                placeTile(draggedTile.dataset.letter, r, c, cell);
                            }
                        }
                    });
                    boardEl.appendChild(cell);
                }
            }
        }

        function renderRack() {
            const rackEl = document.getElementById('rack');
            rackEl.innerHTML = '';
            getCurrentRack().forEach(l => rackEl.appendChild(createTileElement(l, true)));
            
            // Click on rack area to deselect
            rackEl.onclick = (e) => {
                if (e.target === rackEl && selectedTile) {
                    deselectTile();
                }
            };
        }

        function deselectTile() {
            if (selectedTile) selectedTile.classList.remove('selected');
            selectedTile = null;
            selectedLetter = null;
            hideFloatingTile();
            clearTypingMode();
        }

        function showFloatingTile(letter) {
            floatingTile = document.getElementById('floating-tile');
            floatingTile.querySelector('.letter').textContent = letter === '?' ? '?' : letter;
            floatingTile.querySelector('.points').textContent = LETTER_VALUES[letter];
            floatingTile.style.display = 'flex';
        }

        function hideFloatingTile() {
            const ft = document.getElementById('floating-tile');
            ft.style.display = 'none';
            floatingTile = null;
        }

        function handleTileClick(tile) {
            clearTypingMode();
            
            if (selectedTile === tile) {
                // Clicking same tile deselects
                deselectTile();
            } else {
                // Select new tile
                if (selectedTile) selectedTile.classList.remove('selected');
                selectedTile = tile;
                selectedLetter = tile.dataset.letter;
                tile.classList.add('selected');
                showFloatingTile(selectedLetter);
            }
        }

        // Click on placed tile to return to rack
        function handlePlacedTileClick(row, col, e) {
            e.stopPropagation();
            const placement = placedThisTurn.find(p => p.row === row && p.col === col);
            if (placement) {
                // Return to rack
                board[row][col] = null;
                getCurrentRack().push(placement.originalLetter);
                placedThisTurn = placedThisTurn.filter(p => p !== placement);
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                restoreCell(cell, row, col);
                renderRack();
                updateWordPreview();
            }
        }

        // Track mouse for floating tile
        document.addEventListener('mousemove', (e) => {
            if (floatingTile) {
                floatingTile.style.left = e.clientX + 'px';
                floatingTile.style.top = e.clientY + 'px';
            }
        });

        function handleCellClick(row, col, cell) {
            // If cell has a tile placed this turn, return it
            const placement = placedThisTurn.find(p => p.row === row && p.col === col);
            if (placement) {
                handlePlacedTileClick(row, col, event);
                return;
            }
            
            // If cell has permanent tile, ignore
            if (board[row][col]) return;
            
            if (selectedTile) {
                // Place selected tile
                placeTile(selectedTile.dataset.letter, row, col, cell);
                selectedTile.classList.remove('selected');
                selectedTile = null;
                selectedLetter = null;
                hideFloatingTile();
            } else if (!typingCell) {
                // Start typing mode
                startTypingMode(row, col, cell);
            } else if (typingCell.row === row && typingCell.col === col) {
                // Clicking same cell toggles direction
                toggleTypingDirection(cell);
            } else {
                // Clicking different cell, restart typing there
                clearTypingMode();
                startTypingMode(row, col, cell);
            }
        }

        function placeTile(letter, row, col, cell, isBlank = false) {
            let actual = letter;
            let originalLetter = letter;
            
            if (letter === '?') {
                actual = prompt('Blank letter (A-Z):')?.toUpperCase();
                if (!actual || !/^[A-Z]$/.test(actual)) return false;
                originalLetter = '?';
                isBlank = true;
            }
            
            const rack = getCurrentRack(), idx = rack.indexOf(isBlank ? '?' : letter);
            if (idx === -1 && !isBlank) return false;
            if (idx !== -1) rack.splice(idx, 1);

            const prev = placedThisTurn.find(p => p.row === row && p.col === col);
            if (prev) { rack.push(prev.originalLetter); placedThisTurn = placedThisTurn.filter(p => p !== prev); }

            const tile = createTileElement(actual);
            tile.classList.add('placed-this-turn');
            tile.draggable = true;
            tile.dataset.placedRow = row;
            tile.dataset.placedCol = col;
            tile.dataset.originalLetter = isBlank ? '?' : actual;
            if (isBlank) tile.dataset.isBlank = 'true';
            
            // Click placed tile to return to rack
            tile.onclick = (e) => handlePlacedTileClick(row, col, e);
            
            // Drag placed tile to relocate
            tile.addEventListener('dragstart', handlePlacedDragStart);
            tile.addEventListener('dragend', handlePlacedDragEnd);
            
            cell.innerHTML = '';
            cell.appendChild(tile);

            board[row][col] = { letter: actual, isBlank: isBlank };
            placedThisTurn.push({ row, col, letter: actual, originalLetter: isBlank ? '?' : actual, element: tile });

            renderRack();
            updateWordPreview();
            return true;
        }
        
        let draggedPlacedTile = null;
        let draggedFromRow = null;
        let draggedFromCol = null;
        
        function handlePlacedDragStart(e) {
            e.stopPropagation();
            draggedPlacedTile = e.target.closest('.tile');
            draggedFromRow = parseInt(draggedPlacedTile.dataset.placedRow);
            draggedFromCol = parseInt(draggedPlacedTile.dataset.placedCol);
            draggedPlacedTile.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handlePlacedDragEnd(e) {
            if (draggedPlacedTile) {
                draggedPlacedTile.classList.remove('dragging');
            }
            draggedPlacedTile = null;
            draggedFromRow = null;
            draggedFromCol = null;
            document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
        }
        
        function relocatePlacedTile(toRow, toCol) {
            if (draggedFromRow === null || draggedFromCol === null) return;
            if (toRow === draggedFromRow && toCol === draggedFromCol) return;
            
            // Get the placement info
            const placement = placedThisTurn.find(p => p.row === draggedFromRow && p.col === draggedFromCol);
            if (!placement) return;
            
            // Check if target is empty or has a placed-this-turn tile
            if (board[toRow][toCol] && !placedThisTurn.some(p => p.row === toRow && p.col === toCol)) {
                return; // Can't drop on permanent tile
            }
            
            // Remove from old position
            board[draggedFromRow][draggedFromCol] = null;
            const oldCell = document.querySelector(`.cell[data-row="${draggedFromRow}"][data-col="${draggedFromCol}"]`);
            restoreCell(oldCell, draggedFromRow, draggedFromCol);
            
            // If target has a placed tile, swap them
            const targetPlacement = placedThisTurn.find(p => p.row === toRow && p.col === toCol);
            if (targetPlacement) {
                // Move target tile to old position
                board[draggedFromRow][draggedFromCol] = { letter: targetPlacement.letter, isBlank: targetPlacement.originalLetter === '?' };
                targetPlacement.row = draggedFromRow;
                targetPlacement.col = draggedFromCol;
                
                const swapTile = createTileElement(targetPlacement.letter);
                swapTile.classList.add('placed-this-turn');
                swapTile.draggable = true;
                swapTile.dataset.placedRow = draggedFromRow;
                swapTile.dataset.placedCol = draggedFromCol;
                swapTile.dataset.originalLetter = targetPlacement.originalLetter;
                if (targetPlacement.originalLetter === '?') swapTile.dataset.isBlank = 'true';
                swapTile.onclick = (ev) => handlePlacedTileClick(draggedFromRow, draggedFromCol, ev);
                swapTile.addEventListener('dragstart', handlePlacedDragStart);
                swapTile.addEventListener('dragend', handlePlacedDragEnd);
                oldCell.innerHTML = '';
                oldCell.appendChild(swapTile);
                targetPlacement.element = swapTile;
            }
            
            // Place at new position
            const newCell = document.querySelector(`.cell[data-row="${toRow}"][data-col="${toCol}"]`);
            const newTile = createTileElement(placement.letter);
            newTile.classList.add('placed-this-turn');
            newTile.draggable = true;
            newTile.dataset.placedRow = toRow;
            newTile.dataset.placedCol = toCol;
            newTile.dataset.originalLetter = placement.originalLetter;
            if (placement.originalLetter === '?') newTile.dataset.isBlank = 'true';
            newTile.onclick = (ev) => handlePlacedTileClick(toRow, toCol, ev);
            newTile.addEventListener('dragstart', handlePlacedDragStart);
            newTile.addEventListener('dragend', handlePlacedDragEnd);
            
            newCell.innerHTML = '';
            newCell.appendChild(newTile);
            
            board[toRow][toCol] = { letter: placement.letter, isBlank: placement.originalLetter === '?' };
            placement.row = toRow;
            placement.col = toCol;
            placement.element = newTile;
            
            updateWordPreview();
        }

        function startTypingMode(row, col, cell) {
            typingCell = { row, col, element: cell };
            typingDirection = 'H'; // Default horizontal
            cell.classList.add('typing-start');
            showDirectionArrow(cell, 'H');
            document.getElementById('keyboard-hint').textContent = 'Type letters, ↑/↓/←/→ change direction, ESC cancel';
            document.getElementById('typing-input').value = '';
            document.getElementById('typing-input').focus();
        }

        function toggleTypingDirection(cell) {
            typingDirection = typingDirection === 'H' ? 'V' : 'H';
            showDirectionArrow(cell, typingDirection);
        }

        function showDirectionArrow(cell, direction) {
            // Remove existing arrows
            document.querySelectorAll('.direction-arrow').forEach(a => a.remove());
            
            const arrow = document.createElement('span');
            arrow.className = 'direction-arrow';
            arrow.textContent = direction === 'H' ? '→' : '↓';
            cell.appendChild(arrow);
        }

        function clearTypingMode() {
            if (typingCell) typingCell.element.classList.remove('typing-start');
            document.querySelectorAll('.direction-arrow').forEach(a => a.remove());
            typingCell = typingDirection = null;
            document.getElementById('keyboard-hint').textContent = 'Click tile → click cell, OR click cell → type word';
        }

        document.getElementById('typing-input').addEventListener('keydown', e => {
            if (!typingCell) return;
            if (e.key === 'Escape') { clearTypingMode(); return; }
            if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                typingDirection = 'H';
                showDirectionArrow(typingCell.element, 'H');
                e.preventDefault();
                return;
            }
            if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                typingDirection = 'V';
                showDirectionArrow(typingCell.element, 'V');
                e.preventDefault();
                return;
            }
            if (e.key === 'Enter') { clearTypingMode(); return; }
            if (e.key === 'Backspace' && placedThisTurn.length > 0) {
                const last = placedThisTurn.pop();
                board[last.row][last.col] = null;
                getCurrentRack().push(last.originalLetter);
                restoreCell(document.querySelector(`.cell[data-row="${last.row}"][data-col="${last.col}"]`), last.row, last.col);
                renderRack();
                updateWordPreview();
                e.preventDefault();
                return;
            }
            if (/^[A-Za-z]$/.test(e.key)) {
                let row = typingCell.row, col = typingCell.col;
                if (placedThisTurn.length > 0) {
                    const last = placedThisTurn[placedThisTurn.length - 1];
                    row = last.row + (typingDirection === 'V' ? 1 : 0);
                    col = last.col + (typingDirection === 'H' ? 1 : 0);
                }
                // Skip existing tiles
                while (row < 15 && col < 15 && board[row][col] && !placedThisTurn.some(p => p.row === row && p.col === col)) {
                    row += typingDirection === 'V' ? 1 : 0;
                    col += typingDirection === 'H' ? 1 : 0;
                }
                if (row >= 15 || col >= 15) return;
                const letter = e.key.toUpperCase(), rack = getCurrentRack();
                const useLetter = rack.includes(letter) ? letter : (rack.includes('?') ? '?' : null);
                if (!useLetter) { showMessage(`No "${letter}" in rack`, 'error'); return; }
                const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                if (useLetter === '?') {
                    rack.splice(rack.indexOf('?'), 1);
                    const tile = createTileElement(letter);
                    tile.classList.add('placed-this-turn');
                    tile.dataset.isBlank = 'true';
                    tile.onclick = (ev) => handlePlacedTileClick(row, col, ev);
                    cell.innerHTML = '';
                    cell.appendChild(tile);
                    board[row][col] = { letter, isBlank: true };
                    placedThisTurn.push({ row, col, letter, originalLetter: '?', element: tile });
                    renderRack();
                    updateWordPreview();
                } else {
                    placeTile(letter, row, col, cell);
                }
                e.preventDefault();
            }
        });

        function handleDragStart(e) { 
            draggedTile = e.target.closest('.tile'); 
            draggedTile.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleDragEnd() { 
            if (draggedTile) draggedTile.classList.remove('dragging'); 
            draggedTile = null;
            document.querySelectorAll('.cell.selected').forEach(c => c.classList.remove('selected'));
        }

        // Allow dropping back on rack to cancel
        document.getElementById('rack').addEventListener('dragover', e => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        });

        document.getElementById('rack').addEventListener('drop', e => {
            e.preventDefault();
            if (draggedPlacedTile) {
                // Return placed tile to rack
                const placement = placedThisTurn.find(p => p.row === draggedFromRow && p.col === draggedFromCol);
                if (placement) {
                    board[draggedFromRow][draggedFromCol] = null;
                    getCurrentRack().push(placement.originalLetter);
                    placedThisTurn = placedThisTurn.filter(p => p !== placement);
                    const cell = document.querySelector(`.cell[data-row="${draggedFromRow}"][data-col="${draggedFromCol}"]`);
                    restoreCell(cell, draggedFromRow, draggedFromCol);
                    renderRack();
                    updateWordPreview();
                }
                draggedPlacedTile = null;
                draggedFromRow = null;
                draggedFromCol = null;
            }
            // Dragging from rack back to rack = no-op, tile stays
            draggedTile = null;
        });

        function restoreCell(cell, row, col) {
            const type = getCellType(row, col);
            cell.innerHTML = type === 'TW' ? '<span class="premium-text">TRIPLE<br>WORD</span>' :
                type === 'DW' && !(row === 7 && col === 7) ? '<span class="premium-text">DOUBLE<br>WORD</span>' :
                type === 'TL' ? '<span class="premium-text">TRIPLE<br>LETTER</span>' :
                type === 'DL' ? '<span class="premium-text">DOUBLE<br>LETTER</span>' :
                type === 'center' ? '<span class="star">★</span>' : '';
        }

        async function validateWord(word) {
            try { return (await (await fetch('/api/check?word=' + encodeURIComponent(word))).json()).valid; }
            catch { return true; }
        }

        function getFormedWords() {
            if (!placedThisTurn.length) return [];
            const words = [], rows = [...new Set(placedThisTurn.map(p => p.row))], cols = [...new Set(placedThisTurn.map(p => p.col))];
            const isH = rows.length === 1, isV = cols.length === 1;

            const getWord = (startR, startC, dr, dc) => {
                let word = '', positions = [], r = startR, c = startC;
                while (r >= 0 && c >= 0 && board[r][c]) { r -= dr; c -= dc; }
                r += dr; c += dc;
                while (r < 15 && c < 15 && board[r][c]) {
                    word += board[r][c].letter;
                    positions.push({ row: r, col: c, ...board[r][c], isNew: placedThisTurn.some(p => p.row === r && p.col === c) });
                    r += dr; c += dc;
                }
                return word.length > 1 ? { word, positions } : null;
            };

            if (isH || placedThisTurn.length === 1) {
                const w = getWord(placedThisTurn[0].row, Math.min(...placedThisTurn.map(p => p.col)), 0, 1);
                if (w) words.push(w);
            }
            if (isV || placedThisTurn.length === 1) {
                const w = getWord(Math.min(...placedThisTurn.map(p => p.row)), placedThisTurn[0].col, 1, 0);
                if (w && !words.some(x => x.word === w.word)) words.push(w);
            }
            placedThisTurn.forEach(({ row, col }) => {
                if (isH) { const w = getWord(row, col, 1, 0); if (w && !words.some(x => x.word === w.word && x.positions[0].col === w.positions[0].col)) words.push(w); }
                if (isV) { const w = getWord(row, col, 0, 1); if (w && !words.some(x => x.word === w.word && x.positions[0].row === w.positions[0].row)) words.push(w); }
            });
            return words;
        }

        function calculateScore(words) {
            let total = 0;
            words.forEach(({ positions }) => {
                let ws = 0, wm = 1;
                positions.forEach(p => {
                    let v = p.isBlank ? 0 : LETTER_VALUES[p.letter] || 0;
                    if (p.isNew) {
                        if (TL.some(x => x[0] === p.row && x[1] === p.col)) v *= 3;
                        else if (DL.some(x => x[0] === p.row && x[1] === p.col)) v *= 2;
                        if (TW.some(x => x[0] === p.row && x[1] === p.col)) wm *= 3;
                        else if (DW.some(x => x[0] === p.row && x[1] === p.col)) wm *= 2;
                    }
                    ws += v;
                });
                total += ws * wm;
            });
            if (placedThisTurn.length === 7) total += 50;
            return total;
        }

        async function updateWordPreview() {
            const preview = document.getElementById('word-preview'), words = getFormedWords();
            if (!words.length) {
                preview.innerHTML = '<span style="opacity:0.5;font-size:10px;">Place tiles</span>';
                document.getElementById('move-score').textContent = '0';
                document.getElementById('btn-play').disabled = true;
                return;
            }
            preview.innerHTML = '';
            let allValid = true;
            for (const { word } of words) {
                const chip = document.createElement('span');
                chip.className = 'word-chip';
                chip.textContent = word;
                const valid = await validateWord(word);
                chip.classList.add(valid ? 'valid' : 'invalid');
                if (!valid) allValid = false;
                preview.appendChild(chip);
            }
            document.getElementById('move-score').textContent = calculateScore(words);
            document.getElementById('btn-play').disabled = !allValid || !validatePlacement();
        }

        function validatePlacement() {
            if (!placedThisTurn.length) return false;
            const rows = [...new Set(placedThisTurn.map(p => p.row))], cols = [...new Set(placedThisTurn.map(p => p.col))];
            if (rows.length > 1 && cols.length > 1) return false;
            if (isFirstMove) return placedThisTurn.some(p => p.row === 7 && p.col === 7);
            return placedThisTurn.some(({ row, col }) =>
                [[row-1,col],[row+1,col],[row,col-1],[row,col+1]].some(([r,c]) =>
                    r >= 0 && r < 15 && c >= 0 && c < 15 && board[r][c] && !placedThisTurn.some(p => p.row === r && p.col === c)));
        }

        function showMessage(text, type = 'info') {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = 'message ' + type;
            msg.style.display = 'block';
            setTimeout(() => msg.style.display = 'none', 3000);
        }

        async function playWord() {
            const words = getFormedWords();
            for (const { word } of words) if (!(await validateWord(word))) { showMessage(`"${word}" invalid!`, 'error'); return; }
            const score = calculateScore(words);
            scores[currentPlayer - 1] += score;
            placedThisTurn.forEach(p => p.element?.classList.remove('placed-this-turn'));
            placedThisTurn = [];
            isFirstMove = false;
            setCurrentRack([...getCurrentRack(), ...drawTiles(7 - getCurrentRack().length)]);
            showMessage(`+${score} points!`, 'success');
            switchPlayer();
        }

        function recallTiles() {
            placedThisTurn.forEach(({ row, col, originalLetter }) => {
                board[row][col] = null;
                getCurrentRack().push(originalLetter);
                restoreCell(document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`), row, col);
            });
            placedThisTurn = [];
            renderRack();
            updateWordPreview();
            clearTypingMode();
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateUI();
            if (gameMode === 'ai' && currentPlayer === 2) setTimeout(doAiMove, 500);
        }

        async function doAiMove() {
            document.getElementById('ai-thinking').style.display = 'flex';
            const boardData = [];
            for (let r = 0; r < 15; r++) for (let c = 0; c < 15; c++) if (board[r][c]) boardData.push({ row: r, col: c, letter: board[r][c].letter, is_blank: board[r][c].isBlank });
            try {
                const res = await fetch('/api/ai_move', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ board: boardData, rack: getCurrentRack(), difficulty: aiDifficulty }) });
                const data = await res.json();
                document.getElementById('ai-thinking').style.display = 'none';
                if (data.success) {
                    data.tiles.forEach(tile => {
                        const cell = document.querySelector(`.cell[data-row="${tile.row}"][data-col="${tile.col}"]`);
                        cell.innerHTML = '';
                        cell.appendChild(createTileElement(tile.letter));
                        board[tile.row][tile.col] = { letter: tile.letter, isBlank: tile.is_blank };
                        const rack = getCurrentRack(), idx = tile.is_blank ? rack.indexOf('?') : rack.indexOf(tile.letter);
                        if (idx > -1) rack.splice(idx, 1);
                    });
                    scores[1] += data.score;
                    isFirstMove = false;
                    setCurrentRack([...getCurrentRack(), ...drawTiles(7 - getCurrentRack().length)]);
                    showMessage(`AI: "${data.word}" +${data.score}`, 'info');
                } else showMessage('AI passes', 'info');
                switchPlayer();
            } catch { document.getElementById('ai-thinking').style.display = 'none'; showMessage('AI error', 'error'); switchPlayer(); }
        }

        async function getHint() {
            const boardData = [];
            for (let r = 0; r < 15; r++) for (let c = 0; c < 15; c++) if (board[r][c]) boardData.push({ row: r, col: c, letter: board[r][c].letter });
            try {
                const res = await fetch('/api/hint', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ board: boardData, rack: getCurrentRack() }) });
                const data = await res.json();
                if (data.success) showMessage(`Hint: "${data.word}" (${data.start_row},${data.start_col}) ${data.direction} = ${data.score}pts`, 'info');
                else showMessage('No hints', 'info');
            } catch { showMessage('Hint error', 'error'); }
        }

        function updateUI() {
            document.getElementById('player1-score').classList.toggle('current', currentPlayer === 1);
            document.getElementById('player2-score').classList.toggle('current', currentPlayer === 2);
            document.getElementById('player1-score').querySelector('.score').textContent = scores[0];
            document.getElementById('player2-score').querySelector('.score').textContent = scores[1];
            document.getElementById('turn-indicator').textContent = currentPlayer === 1 ? 'Your turn' : (gameMode === 'ai' ? 'AI thinking...' : 'Player 2');
            document.getElementById('bag-count').textContent = bag.length;
            document.getElementById('rack-label').textContent = gameMode === 'ai' && currentPlayer === 2 ? 'AI' : 'Your Rack';
            if (gameMode === 'ai' && currentPlayer === 2) document.getElementById('rack').innerHTML = '';
            else renderRack();
            updateWordPreview();
        }

        // Global escape key to deselect
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                deselectTile();
            }
        });

        document.querySelectorAll('.mode-btn').forEach(btn => btn.addEventListener('click', () => {
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            gameMode = btn.dataset.mode;
            document.getElementById('difficulty').style.display = gameMode === 'ai' ? 'inline' : 'none';
            document.getElementById('player2-name').textContent = gameMode === 'ai' ? 'AI' : 'Player 2';
            initGame();
        }));

        document.getElementById('difficulty').addEventListener('change', e => aiDifficulty = e.target.value);
        document.getElementById('btn-play').addEventListener('click', playWord);
        document.getElementById('btn-recall').addEventListener('click', recallTiles);
        document.getElementById('btn-shuffle').addEventListener('click', () => { shuffleArray(getCurrentRack()); renderRack(); });
        document.getElementById('btn-hint').addEventListener('click', getHint);
        document.getElementById('btn-pass').addEventListener('click', () => { recallTiles(); showMessage('Passed', 'info'); switchPlayer(); });

        function initGame() {
            board = Array(15).fill(null).map(() => Array(15).fill(null));
            scores = [0, 0]; currentPlayer = 1; placedThisTurn = []; isFirstMove = true;
            initBag(); initBoard();
            racks = [drawTiles(7), drawTiles(7)];
            updateUI();
        }

        initGame();
    </script>
</body>
</html>
